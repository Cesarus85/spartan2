<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo-Style WebXR Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

        // Basic setup for WebXR with Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Player setup (rig for locomotion)
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        // Camera is added to playerGroup; XR will update its local matrix
        playerGroup.add(camera);
        // No manual camera.position set; XR handles head height

        // Simplified Spartan body (positioned below camera - adjust based on head height)
        const playerBody = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0x006400 }) // Green Spartan armor color
        );
        playerBody.position.y = -1.6; // Approximate below head
        playerGroup.add(playerBody);

        // Controllers added to playerGroup so they move with locomotion
        const controller1 = renderer.xr.getController(0); // Left controller
        const controller2 = renderer.xr.getController(1); // Right controller
        playerGroup.add(controller1);
        playerGroup.add(controller2);

        // Gun in left hand (simplified as a box for Master Chief's assault rifle)
        const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0, -0.1, -0.3); // Position in hand
        // Rotated so the long side (barrel) points forward
        gun.rotation.x = 0;
        gun.rotation.y = 0;
        gun.rotation.z = 0;
        controller1.add(gun);

        // Store all collidable objects
        const collidableObjects = [];

        // Shooting mechanics
        let bullets = [];
        controller1.addEventListener('selectstart', () => {
            // Fire bullet on left trigger
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            bullet.position.copy(controller1.getWorldPosition(new THREE.Vector3()));
            bullet.quaternion.copy(controller1.getWorldQuaternion(new THREE.Quaternion()));
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(bullet.quaternion);
            bullet.velocity = direction.multiplyScalar(10); // Speed
            scene.add(bullet);
            bullets.push(bullet);
        });

        // Map: 20x20 ground plane with some unevenness and obstacles
        const groundGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
        groundGeometry.rotateX(-Math.PI / 2);
        // Add some height variation
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 2; i < vertices.length; i += 3) {
            vertices[i] += Math.random() * 0.5 - 0.25; // Small hills/valleys
        }
        groundGeometry.attributes.position.needsUpdate = true;
        groundGeometry.computeVertexNormals();
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        scene.add(ground);

        // Obstacles (simple boxes)
        for (let i = 0; i < 10; i++) {
            const obstacle = new THREE.Mesh(
                new THREE.BoxGeometry(Math.random() * 2 + 1, Math.random() * 2 + 1, Math.random() * 2 + 1),
                new THREE.MeshStandardMaterial({ color: 0xA9A9A9 })
            );
            obstacle.position.set(
                Math.random() * 20 - 10,
                obstacle.geometry.parameters.height / 2,
                Math.random() * 20 - 10
            );
            scene.add(obstacle);
            collidableObjects.push(obstacle);
        }

        // Central fortress (simple structure)
        const fortressGroup = new THREE.Group();
        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); // Dark color
        const wall1 = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 0.5), wallMaterial);
        wall1.position.set(0, 1.5, 2.5);
        fortressGroup.add(wall1);
        collidableObjects.push(wall1);
        const wall2 = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 0.5), wallMaterial);
        wall2.position.set(0, 1.5, -2.5);
        fortressGroup.add(wall2);
        collidableObjects.push(wall2);
        const wall3 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 5), wallMaterial);
        wall3.position.set(2.5, 1.5, 0);
        fortressGroup.add(wall3);
        collidableObjects.push(wall3);
        const wall4 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 5), wallMaterial);
        wall4.position.set(-2.5, 1.5, 0);
        fortressGroup.add(wall4);
        collidableObjects.push(wall4);
        // Entrance (gap in front wall)
        // Roof
        const roof = new THREE.Mesh(new THREE.BoxGeometry(5, 0.5, 5), wallMaterial);
        roof.position.set(0, 3.25, 0);
        fortressGroup.add(roof);
        collidableObjects.push(roof);
        // Interior floor
        const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 4), groundMaterial);
        interiorFloor.position.set(0, 0.05, 0);
        fortressGroup.add(interiorFloor);
        collidableObjects.push(interiorFloor);
        scene.add(fortressGroup);
        
        // Add ground to collidable objects
        collidableObjects.push(ground);

        // Sky with Halo ring (simple skybox and ring model)
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Halo ring (torus for simplicity)
        const ringGeometry = new THREE.TorusGeometry(100, 5, 16, 100);
        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const haloRing = new THREE.Mesh(ringGeometry, ringMaterial);
        haloRing.rotation.x = Math.PI / 2;
        haloRing.position.set(0, 200, -300); // Visible in the sky
        scene.add(haloRing);

        // Movement controls
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 5;
        const jumpSpeed = 8; // Higher jump due to lower gravity
        const gravity = -9.8 * 0.5; // Half Earth gravity
        let isJumping = false;
        let playerYRotation = 0; // Track player's Y rotation separately
        
        // Raycaster for collision detection
        const raycaster = new THREE.Raycaster();

        // Controller grips for hands (optional visualization) - add to playerGroup
        const grip1 = renderer.xr.getControllerGrip(0);
        const grip2 = renderer.xr.getControllerGrip(1);
        playerGroup.add(grip1);
        playerGroup.add(grip2);

        // Input handling
        let leftThumbstick = { x: 0, y: 0 };
        let rightThumbstick = { x: 0, y: 0 };
        let jumpPressed = false;

        // Mock input for desktop testing (use gamepad API in VR)
        window.addEventListener('keydown', (e) => {
            // For testing without VR: WASD movement, space jump, arrow keys turn
            if (e.key === 'w') leftThumbstick.y = -1; // Adjusted for forward
            if (e.key === 's') leftThumbstick.y = 1;
            if (e.key === 'a') leftThumbstick.x = -1;
            if (e.key === 'd') leftThumbstick.x = 1;
            if (e.key === 'ArrowLeft') rightThumbstick.x = -1;
            if (e.key === 'ArrowRight') rightThumbstick.x = 1;
            if (e.key === ' ') jumpPressed = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 's') leftThumbstick.y = 0;
            if (e.key === 'a' || e.key === 'd') leftThumbstick.x = 0;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') rightThumbstick.x = 0;
            if (e.key === ' ') jumpPressed = false;
        });

        // In VR, use gamepad axes - for Quest, thumbstick is axes[2] and [3]
        function onXRFrame() {
            // Reset inputs first to prevent drift
            leftThumbstick = { x: 0, y: 0 };
            rightThumbstick = { x: 0, y: 0 };
            jumpPressed = false;
            
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                const inputSources = session.inputSources;
                inputSources.forEach((source, index) => {
                    if (source.gamepad) {
                        const axes = source.gamepad.axes;
                        // Apply deadzone to prevent drift
                        const deadzone = 0.1;
                        if (index === 0) { // Left controller
                            const x = axes[2] || 0;
                            const y = axes[3] || 0;
                            leftThumbstick.x = Math.abs(x) > deadzone ? x : 0;
                            leftThumbstick.y = Math.abs(y) > deadzone ? y : 0;
                        } else if (index === 1) { // Right controller
                            const x = axes[2] || 0;
                            rightThumbstick.x = Math.abs(x) > deadzone ? x : 0;
                            // A button for jump (button[4] for A on right Quest controller)
                            jumpPressed = source.gamepad.buttons[4]?.pressed || false;
                        }
                    }
                });
            }
        }

        // Animation loop
        function animate(time) {
            renderer.setAnimationLoop(animate);

            onXRFrame();

            // Turning (smooth turn with right thumbstick) - update player rotation
            playerYRotation -= rightThumbstick.x * 0.05;
            playerGroup.rotation.y = playerYRotation;

            // Movement (forward/backward and strafe based on player's Y rotation only)
            if (Math.abs(leftThumbstick.x) > 0 || Math.abs(leftThumbstick.y) > 0) {
                direction.set(0, 0, 0);
                direction.x = leftThumbstick.x; // Strafe left/right
                direction.z = leftThumbstick.y; // Forward/back (positive y = backward)
                direction.normalize();
                
                // Apply only Y rotation to movement direction (not full camera quaternion)
                const yRotationMatrix = new THREE.Matrix4().makeRotationY(playerYRotation);
                direction.applyMatrix4(yRotationMatrix);
                
                velocity.x = direction.x * moveSpeed;
                velocity.z = direction.z * moveSpeed;
            } else {
                velocity.x = 0;
                velocity.z = 0;
            }

            // Gravity
            velocity.y += gravity * 0.016;
            
            // Calculate new position
            const deltaPosition = velocity.clone().multiplyScalar(0.016);
            const newPosition = playerGroup.position.clone().add(deltaPosition);
            
            // Check collision with ground and objects
            const playerHeight = 1.6; // Height of player capsule
            const playerRadius = 0.5;
            let onGround = false;
            let groundHeight = 0;
            
            // Check collision with all objects
            for (const obj of collidableObjects) {
                const box = new THREE.Box3().setFromObject(obj);
                
                // Check if player is above object and would land on it
                if (newPosition.x + playerRadius > box.min.x && 
                    newPosition.x - playerRadius < box.max.x &&
                    newPosition.z + playerRadius > box.min.z && 
                    newPosition.z - playerRadius < box.max.z) {
                    
                    // Check if we're falling onto this object
                    if (newPosition.y <= box.max.y + playerHeight && 
                        playerGroup.position.y >= box.max.y + playerHeight) {
                        groundHeight = Math.max(groundHeight, box.max.y);
                        onGround = true;
                    }
                }
            }
            
            // Apply position with collision
            if (onGround && newPosition.y <= groundHeight + playerHeight) {
                playerGroup.position.x = newPosition.x;
                playerGroup.position.z = newPosition.z;
                playerGroup.position.y = groundHeight;
                velocity.y = 0;
                isJumping = false;
            } else {
                playerGroup.position.add(deltaPosition);
            }
            
            // Jumping
            if (jumpPressed && !isJumping) {
                velocity.y = jumpSpeed;
                isJumping = true;
            }

            // Bullet update with collision detection
            bullets.forEach((bullet, index) => {
                const oldPosition = bullet.position.clone();
                bullet.position.add(bullet.velocity.clone().multiplyScalar(0.016));
                
                // Check collision with objects
                const raycaster = new THREE.Raycaster(oldPosition, bullet.velocity.clone().normalize());
                const intersects = raycaster.intersectObjects(collidableObjects);
                
                let hitSomething = false;
                for (const intersect of intersects) {
                    if (intersect.distance <= bullet.velocity.length() * 0.016) {
                        hitSomething = true;
                        break;
                    }
                }
                
                if (hitSomething || bullet.position.length() > 100) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
