<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Halo-Style WebXR Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

// --- Renderer / Scene / Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));
const clock = new THREE.Clock();

// --- Lights ---
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5,10,5);
scene.add(dirLight);

// --- Player rig ---
const playerGroup = new THREE.Group();
// Spawn auf dem Dach wie bisher
playerGroup.position.set(0, 3.25 + 1.6, 0);
scene.add(playerGroup);
playerGroup.add(camera);

// Spartan-„Body“ (einfach)
const playerBody = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
  new THREE.MeshStandardMaterial({ color: 0x006400 })
);
playerBody.position.y = -1.6;
playerGroup.add(playerBody);

// Controller + Grips
const controllerLeft  = renderer.xr.getController(0);
const controllerRight = renderer.xr.getController(1);
playerGroup.add(controllerLeft, controllerRight);
const gripLeft  = renderer.xr.getControllerGrip(0);
const gripRight = renderer.xr.getControllerGrip(1);
playerGroup.add(gripLeft, gripRight);

// „Gun“ an die linke Hand (wie gehabt)
const gun = new THREE.Mesh(
  new THREE.BoxGeometry(0.1,0.1,0.5),
  new THREE.MeshStandardMaterial({ color: 0x808080 })
);
gun.position.set(0,-0.1,-0.3);
controllerLeft.add(gun);

// --- Level: Boden, Hindernisse, Festung ---
// Cache für statische Boxen + explizit begehbare Meshes
const staticColliders = []; // { obj, box }
const walkableMeshes  = []; // echte Oberflächen, auf denen gelandet werden darf

function addStaticCollider(obj){
  const box = new THREE.Box3().setFromObject(obj);
  staticColliders.push({ obj, box });
}
function addWalkable(obj){
  walkableMeshes.push(obj);
}

const groundGeometry = new THREE.PlaneGeometry(20,20,20,20);
groundGeometry.rotateX(-Math.PI/2);
// leichte Unebenheiten
const verts = groundGeometry.attributes.position.array;
for (let i=2; i<verts.length; i+=3) {
  verts[i] += Math.random()*0.5 - 0.25;
}
groundGeometry.attributes.position.needsUpdate = true;
groundGeometry.computeVertexNormals();
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
scene.add(ground);
addStaticCollider(ground);
addWalkable(ground);

// Hindernisse (graue Blöcke → begehbar!)
for (let i=0; i<10; i++){
  const w = new THREE.Mesh(
    new THREE.BoxGeometry(Math.random()*2+1, Math.random()*2+1, Math.random()*2+1),
    new THREE.MeshStandardMaterial({ color: 0xA9A9A9 })
  );
  w.position.set(Math.random()*20-10, w.geometry.parameters.height/2, Math.random()*20-10);
  scene.add(w);
  addStaticCollider(w);
  addWalkable(w); // oben drauf landen möglich
}

// Festung
const fortressGroup = new THREE.Group();
const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

const wall1Left = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Left.position.set(-1.75,1.5,2.5);
fortressGroup.add(wall1Left); addStaticCollider(wall1Left);

const wall1Right = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Right.position.set(1.75,1.5,2.5);
fortressGroup.add(wall1Right); addStaticCollider(wall1Right);

const lintel = new THREE.Mesh(new THREE.BoxGeometry(2,0.5,0.5), wallMat);
lintel.position.set(0,2.75,2.5);
fortressGroup.add(lintel); addStaticCollider(lintel);

const wallBack = new THREE.Mesh(new THREE.BoxGeometry(5,3,0.5), wallMat);
wallBack.position.set(0,1.5,-2.5);
fortressGroup.add(wallBack); addStaticCollider(wallBack);

const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallLeft.position.set(2.5,1.5,0);
fortressGroup.add(wallLeft); addStaticCollider(wallLeft);

const wallRight = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallRight.position.set(-2.5,1.5,0);
fortressGroup.add(wallRight); addStaticCollider(wallRight);

const roof = new THREE.Mesh(new THREE.BoxGeometry(5,0.5,5), wallMat);
roof.position.set(0,3.25,0);
fortressGroup.add(roof); addStaticCollider(roof); addWalkable(roof);

const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4,0.1,4), groundMaterial);
interiorFloor.position.set(0,0.05,0);
fortressGroup.add(interiorFloor); addStaticCollider(interiorFloor); addWalkable(interiorFloor);

scene.add(fortressGroup);

// Himmel + Halo-Ring
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(500,32,32),
  new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide })
);
scene.add(sky);
const haloRing = new THREE.Mesh(
  new THREE.TorusGeometry(100,5,16,100),
  new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
);
haloRing.rotation.x = Math.PI/2;
haloRing.position.set(0,200,-300);
scene.add(haloRing);

// --- Input ---
let moveAxis = {x:0, y:0}, turnAxis = {x:0, y:0};
let jumpPressed = false;

// Waffen/Feuer Eingaben
let fireHeld = false;
let rightBWasPressed = false; // für XR-Waffenwechsel (B-Button Heuristik)

// Tastatur
window.addEventListener('keydown', (e)=>{
  if (e.key==='w') moveAxis.y = -1;
  if (e.key==='s') moveAxis.y =  1;
  if (e.key==='a') moveAxis.x = -1;
  if (e.key==='d') moveAxis.x =  1;
  if (e.key==='ArrowLeft')  turnAxis.x = -1;
  if (e.key==='ArrowRight') turnAxis.x =  1;
  if (e.key===' ') { jumpPressed = true; fireHeld = true; }

  // Waffenwechsel per Tastatur
  if (e.key === '1') currentWeapon = 0;
  if (e.key === '2') currentWeapon = 1;
});
window.addEventListener('keyup', (e)=>{
  if (e.key==='w' || e.key==='s') moveAxis.y = 0;
  if (e.key==='a' || e.key==='d') moveAxis.x = 0;
  if (e.key==='ArrowLeft' || e.key==='ArrowRight') turnAxis.x = 0;
  if (e.key===' ') { jumpPressed = false; fireHeld = false; }
});

// XR-Input
function readXRInput(session){
  moveAxis.x = moveAxis.y = 0;
  turnAxis.x = turnAxis.y = 0;
  jumpPressed = false;

  for (const source of session.inputSources){
    if (!source.gamepad) continue;
    const { axes, buttons } = source.gamepad;
    const dead = 0.1;
    const axX = Math.abs(axes[2]||0) > dead ? axes[2] : 0;
    const axY = Math.abs(axes[3]||0) > dead ? axes[3] : 0;

    if (source.handedness === 'left'){
      moveAxis.x = axX; moveAxis.y = axY;

      // Trigger links = feuern (selectstart/selectend setzen fireHeld zusätzlich)
      const triggerPressed = (buttons[0] && buttons[0].pressed) || false;
      if (triggerPressed) fireHeld = true;

    } else if (source.handedness === 'right'){
      turnAxis.x = axX; turnAxis.y = axY;

      // A-Button (häufig index 4) = springen (Heuristik)
      jumpPressed = buttons.some((b,i)=> i===4 ? b.pressed : false);

      // B-Button (häufig index 5) = Waffenwechsel (Edge-Detection)
      const bPressed = (buttons[5] && buttons[5].pressed) || false;
      if (bPressed && !rightBWasPressed) {
        currentWeapon = (currentWeapon + 1) % weapons.length;
      }
      rightBWasPressed = bPressed;
    }
  }
}
function onXRFrame(){
  if (renderer.xr.isPresenting){
    readXRInput(renderer.xr.getSession());
  }
}

// Zusätzliche XR-Events für feuern halten/loslassen
controllerLeft.addEventListener('selectstart', ()=> { fireHeld = true; });
controllerLeft.addEventListener('selectend',   ()=> { fireHeld = false; });

// --- Movement / Physics ---
const velocity = new THREE.Vector3();   // NUR für X/Z
const direction = new THREE.Vector3();
const moveSpeed = 5;
let playerYRotation = 0;

// Vertikal-Physik (Jump-Fix)
let vy = 0;
let grounded = false;
let coyoteTimer = 0;
const COYOTE_MAX = 0.1;     // 100 ms Gnadenzeit
const JUMP = 8;             // Sprung-Impuls
const GRAV = -9.8 * 0.5;    // halbe Erdanziehung
const PROBE = 0.25;         // Snap-Distanz

const downRay = new THREE.Raycaster();
const downDir = new THREE.Vector3(0,-1,0);

// NEU: Up-Ray für Decken-Kollision
const upRay = new THREE.Raycaster();
const upDir = new THREE.Vector3(0,1,0);

function landIfGroundClose(pos){
  // leicht oberhalb casten, damit wir zuverlässig treffen
  downRay.set(new THREE.Vector3(pos.x, pos.y + 0.2, pos.z), downDir);
  const hits = downRay.intersectObjects(walkableMeshes, true);
  if (!hits.length) return false;
  const hit = hits[0];

  // Nur beim FALLEN und wenn Boden wirklich nah ist „einrasten“
  if (vy <= 0 && hit.distance <= (0.2 + PROBE)) {
    pos.y = pos.y + 0.2 - hit.distance;
    vy = 0;
    grounded = true;
    coyoteTimer = 0;
    return true;
  }
  return false;
}

// NEU: Decken-Block – verhindert Durchspringen nach oben
function blockCeiling(pos, dt, playerHeight){
  if (vy <= 0) return; // nur bei Aufwärtsbewegung
  // Ray vom alten Kopf (vor der Bewegung) nach oben über die zurückgelegte Strecke
  const headOldY = playerGroup.position.y + playerHeight;
  upRay.set(new THREE.Vector3(pos.x, headOldY, pos.z), upDir);
  upRay.far = (vy * dt) + 0.05; // kleine Toleranz
  const hits = upRay.intersectObjects(staticColliders.map(e=>e.obj), true);
  if (!hits.length) return;

  const hit = hits[0];
  const clampY = hit.point.y - playerHeight;
  if (pos.y > clampY) pos.y = clampY; // unter die Decke klemmen
  vy = 0; // Kopf stößt an -> vertikale Geschwindigkeit null
}

// --- Shooting: Schritt B (Waffen + Pool) ---
const weapons = [
  { name: 'AR', speed: 16, radius: 0.04, color: 0x00ffea, fireRate: 10 }, // 10/s
  { name: 'BR', speed: 28, radius: 0.03, color: 0xff6a00, fireRate: 5  }, // 5/s
];
let currentWeapon = 0;
let fireCooldown = 0;

const bulletPool = [];
const bullets = [];

function acquireBullet(radius, color){
  let m = bulletPool.pop();
  if (!m){
    m = new THREE.Mesh(
      new THREE.SphereGeometry(radius, 8, 8),
      new THREE.MeshBasicMaterial({ color })
    );
  } else {
    if (!m.geometry.parameters || m.geometry.parameters.radius !== radius){
      m.geometry.dispose();
      m.geometry = new THREE.SphereGeometry(radius, 8, 8);
    }
    m.material.color.setHex(color);
  }
  m.visible = true;
  return m;
}
function releaseBullet(m){
  m.visible = false;
  m.position.set(0,-999,0);
  if (m.velocity) m.velocity.set(0,0,0);
  bulletPool.push(m);
}

// --- Update ---
function update(dt){
  // Turning (smooth; Snap-Turn kommt später als Option)
  playerYRotation -= turnAxis.x * 0.05;
  playerGroup.rotation.y = playerYRotation;

  // Horizontal movement (lokal)
  if (Math.abs(moveAxis.x) > 0 || Math.abs(moveAxis.y) > 0) {
    direction.set(moveAxis.x, 0, moveAxis.y).normalize();
    const yRot = new THREE.Matrix4().makeRotationY(playerYRotation);
    direction.applyMatrix4(yRot);
    velocity.x = direction.x * moveSpeed;
    velocity.z = direction.z * moveSpeed;
  } else {
    velocity.x = 0; velocity.z = 0;
  }

  // ---- Vertikal: Reihenfolge wichtig ----
  if (!grounded) coyoteTimer = Math.max(0, coyoteTimer - dt);

  // Jump (vor Gravity / vor Landen)
  if (jumpPressed && (grounded || coyoteTimer > 0)){
    vy = JUMP;
    grounded = false;
    coyoteTimer = 0;
  }

  // Gravity
  vy += GRAV * dt;

  // Position vorschlagen
  const newPos = playerGroup.position.clone();
  newPos.x += velocity.x * dt;
  newPos.z += velocity.z * dt;
  newPos.y += vy * dt;

  // --- Kollisionen horizontal (Wände/Hindernisse), Boden/Decken separat ---
  const playerHeight = 1.6;
  const playerRadius = 0.5;
  let finalPos = newPos.clone();

  // Seiten/Decken durch Boxen (statisch gecached) – Roof war bisher ausgenommen,
  // wir lassen die Decke jetzt vom Up-Ray blocken (siehe unten).
  const wallEntries = staticColliders.filter(e => e.obj !== ground && e.obj !== interiorFloor && e.obj !== roof);

  for (const { box } of wallEntries){
    const pBox = {
      minX: finalPos.x - playerRadius,
      maxX: finalPos.x + playerRadius,
      minZ: finalPos.z - playerRadius,
      maxZ: finalPos.z + playerRadius,
      minY: finalPos.y,
      maxY: finalPos.y + playerHeight
    };

    if (pBox.maxX > box.min.x && pBox.minX < box.max.x &&
        pBox.maxZ > box.min.z && pBox.minZ < box.max.z){

      // Seiten-Kollision blocken (X/Z), wenn wir in den Bereich schieben
      if (finalPos.y < box.max.y && finalPos.y + playerHeight > box.min.y){
        const oldBox = {
          minX: playerGroup.position.x - playerRadius,
          maxX: playerGroup.position.x + playerRadius,
          minZ: playerGroup.position.z - playerRadius,
          maxZ: playerGroup.position.z + playerRadius
        };
        if (!(oldBox.maxX > box.min.x && oldBox.minX < box.max.x)) {
          finalPos.x = playerGroup.position.x;
        }
        if (!(oldBox.maxZ > box.min.z && oldBox.minZ < box.max.z)) {
          finalPos.z = playerGroup.position.z;
        }
      }
    }
  }

  // *** NEU: Decke blocken, bevor wir Bodenfang machen ***
  blockCeiling(finalPos, dt, playerHeight);

  // Bodenfang nur beim Fallen & nahe am Boden
  const landed = landIfGroundClose(finalPos);
  if (!landed && grounded && vy < 0){
    grounded = false;
    coyoteTimer = COYOTE_MAX;
  }

  // Position anwenden
  playerGroup.position.copy(finalPos);

  // --- Schießen (Cooldown + Pool + Waffen-Config) ---
  fireCooldown = Math.max(0, fireCooldown - dt);
  if (fireHeld && fireCooldown === 0){
    const w = weapons[currentWeapon];
    fireCooldown = 1 / w.fireRate;

    const bullet = acquireBullet(w.radius, w.color);
    const origin = controllerLeft.getWorldPosition(new THREE.Vector3());
    const quat   = controllerLeft.getWorldQuaternion(new THREE.Quaternion());
    bullet.position.copy(origin);
    bullet.quaternion.copy(quat);

    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(quat).normalize();
    bullet.velocity = dir.multiplyScalar(w.speed);
    scene.add(bullet);
    bullets.push(bullet);
  }

  // --- Bullets updaten (rückwärts iterieren, robust gegen splice) ---
  const staticObjs = staticColliders.map(e => e.obj);
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    const old = b.position.clone();
    b.position.addScaledVector(b.velocity, dt);

    const ray = new THREE.Raycaster(old, b.velocity.clone().normalize());
    const dist = b.velocity.length() * dt;
    ray.far = dist;
    const hits = ray.intersectObjects(staticObjs);
    const hit = hits.length > 0;

    if (hit || b.position.length() > 150){
      scene.remove(b);
      releaseBullet(b);
      bullets.splice(i,1);
    }
  }
}

// --- Animation Loop ---
renderer.setAnimationLoop(()=>{
  const dt = Math.min(clock.getDelta(), 1/30);
  onXRFrame();
  update(dt);
  renderer.render(scene, camera);
});

// --- Resize ---
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
