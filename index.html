<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Halo-Style WebXR Shooter</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    canvas { display: block; }
    /* kleines Pre-VR Overlay, um Settings auch vor dem Eintritt setzen zu können */
    #overlay {
      position: fixed; inset: 12px auto auto 12px; background: rgba(0,0,0,.6);
      padding: 10px 12px; border-radius: 10px; color: #fff; z-index: 10; backdrop-filter: blur(4px);
      max-width: 320px; font-size: 14px; line-height: 1.4;
    }
    #overlay label { display: block; margin: 6px 0; }
    #overlay .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #overlay button, #overlay select {
      border: 1px solid #444; background: #111; color: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer;
    }
    #overlay button:hover { background: #151515; }
  </style>
</head>
<body>
<div id="overlay">
  <div style="font-weight:600;margin-bottom:6px;">Settings (Pre-VR)</div>
  <label class="row">
    Turn Mode:
    <select id="ovTurnMode">
      <option value="smooth">Smooth</option>
      <option value="snap">Snap</option>
    </select>
  </label>
  <label class="row">
    Snap Angle:
    <select id="ovSnapAngle">
      <option value="30">30°</option>
      <option value="45">45°</option>
    </select>
  </label>
  <label class="row">
    Weapon Hand:
    <select id="ovWeaponHand">
      <option value="left">Left</option>
      <option value="right">Right</option>
    </select>
  </label>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

// --- Renderer / Scene / Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));
const clock = new THREE.Clock();

// --- Lights ---
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5,10,5);
scene.add(dirLight);

// --- Player rig ---
const playerGroup = new THREE.Group();
playerGroup.position.set(0, 3.25 + 1.6, 0);
scene.add(playerGroup);
playerGroup.add(camera);

// Spartan-„Body“
const playerBody = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
  new THREE.MeshStandardMaterial({ color: 0x006400 })
);
playerBody.position.y = -1.6;
playerGroup.add(playerBody);

// Controller + Grips
const controllerLeft  = renderer.xr.getController(0);
const controllerRight = renderer.xr.getController(1);
playerGroup.add(controllerLeft, controllerRight);
const gripLeft  = renderer.xr.getControllerGrip(0);
const gripRight = renderer.xr.getControllerGrip(1);
playerGroup.add(gripLeft, gripRight);

// „Gun“
const gun = new THREE.Mesh(
  new THREE.BoxGeometry(0.1,0.1,0.5),
  new THREE.MeshStandardMaterial({ color: 0x808080 })
);
gun.position.set(0,-0.1,-0.3);

// --- SETTINGS (live veränderbar) ---
const settings = {
  turnMode: 'smooth',   // 'smooth' | 'snap'
  snapAngleDeg: 30,     // 30 | 45
  weaponHand: 'left',   // 'left' | 'right'
};

// Pre-VR overlay bind
const ovTurnMode   = document.getElementById('ovTurnMode');
const ovSnapAngle  = document.getElementById('ovSnapAngle');
const ovWeaponHand = document.getElementById('ovWeaponHand');
ovTurnMode.value   = settings.turnMode;
ovSnapAngle.value  = String(settings.snapAngleDeg);
ovWeaponHand.value = settings.weaponHand;
ovTurnMode.onchange   = ()=> settings.turnMode = ovTurnMode.value;
ovSnapAngle.onchange  = ()=> settings.snapAngleDeg = parseInt(ovSnapAngle.value,10);
ovWeaponHand.onchange = ()=> attachGunTo(ovWeaponHand.value);

// Hilfsfunktionen
function attachGunTo(hand){
  settings.weaponHand = hand === 'right' ? 'right' : 'left';
  gun.removeFromParent();
  if (settings.weaponHand === 'left') controllerLeft.add(gun);
  else controllerRight.add(gun);
}
attachGunTo(settings.weaponHand);

// --- Level helpers ---
const staticColliders = []; // { obj, box }
const walkableMeshes  = [];

function addStaticCollider(obj){
  const box = new THREE.Box3().setFromObject(obj);
  staticColliders.push({ obj, box });
}
function addWalkable(obj){ walkableMeshes.push(obj); }

// --- Ground ---
const groundGeometry = new THREE.PlaneGeometry(20,20,20,20);
groundGeometry.rotateX(-Math.PI/2);
// Unebenheiten
const verts = groundGeometry.attributes.position.array;
for (let i=2; i<verts.length; i+=3) verts[i] += Math.random()*0.5 - 0.25;
groundGeometry.attributes.position.needsUpdate = true;
groundGeometry.computeVertexNormals();

const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
scene.add(ground);
addStaticCollider(ground);
addWalkable(ground);

// --- Fortress (erst Festung, dann Hindernisse!) ---
const fortressGroup = new THREE.Group();
const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

const wall1Left = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Left.position.set(-1.75,1.5,2.5);
fortressGroup.add(wall1Left); addStaticCollider(wall1Left);

const wall1Right = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Right.position.set(1.75,1.5,2.5);
fortressGroup.add(wall1Right); addStaticCollider(wall1Right);

const lintel = new THREE.Mesh(new THREE.BoxGeometry(2,0.5,0.5), wallMat);
lintel.position.set(0,2.75,2.5);
fortressGroup.add(lintel); addStaticCollider(lintel);

const wallBack = new THREE.Mesh(new THREE.BoxGeometry(5,3,0.5), wallMat);
wallBack.position.set(0,1.5,-2.5);
fortressGroup.add(wallBack); addStaticCollider(wallBack);

const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallLeft.position.set(2.5,1.5,0);
fortressGroup.add(wallLeft); addStaticCollider(wallLeft);

const wallRight = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallRight.position.set(-2.5,1.5,0);
fortressGroup.add(wallRight); addStaticCollider(wallRight);

const roof = new THREE.Mesh(new THREE.BoxGeometry(5,0.5,5), wallMat);
roof.position.set(0,3.25,0);
fortressGroup.add(roof); addStaticCollider(roof); addWalkable(roof);

const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4,0.1,4), groundMaterial);
interiorFloor.position.set(0,0.05,0);
fortressGroup.add(interiorFloor); addStaticCollider(interiorFloor); addWalkable(interiorFloor);

scene.add(fortressGroup);

// --- No-Spawn-Zonen definieren ---
const forbiddenZones = [
  new THREE.Box3(new THREE.Vector3(-2.7,0.0,-2.7), new THREE.Vector3(2.7,4.5,2.9)), // Festung
  new THREE.Box3(new THREE.Vector3(-1.2,0.0,1.2),  new THREE.Vector3(1.2,3.0,4.0)), // Tor-Korridor
];

// --- Hindernisse (NACH Festung, mit Avoid-Spawn) ---
function intersectsForbidden(box){
  for (const forb of forbiddenZones){
    if (box.intersectsBox(forb)) return true;
  }
  return false;
}
function placeBlockAvoiding(block, attempts = 60){
  const size = block.geometry.parameters;
  const hx = (size.width  || 1)/2;
  const hy = (size.height || 1)/2;
  const hz = (size.depth  || 1)/2;

  for (let i=0; i<attempts; i++){
    const x = Math.random()*20 - 10;
    const z = Math.random()*20 - 10;
    const y = hy; // auf Boden stellen

    const min = new THREE.Vector3(x - hx, 0, z - hz);
    const max = new THREE.Vector3(x + hx, y*2, z + hz);
    const candidate = new THREE.Box3(min, max);

    if (!intersectsForbidden(candidate)){
      block.position.set(x, y, z);
      return true;
    }
  }
  return false;
}
for (let i=0; i<10; i++){
  const w = new THREE.Mesh(
    new THREE.BoxGeometry(Math.random()*2+1, Math.random()*2+1, Math.random()*2+1),
    new THREE.MeshStandardMaterial({ color: 0xA9A9A9 })
  );
  const ok = placeBlockAvoiding(w);
  if (!ok){
    w.position.set(12 + Math.random()*6, (w.geometry.parameters.height||1)/2, 12 + Math.random()*6);
  }
  scene.add(w);
  addStaticCollider(w);
  addWalkable(w);
}

// --- Sky + Ring ---
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(500,32,32),
  new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide })
);
scene.add(sky);
const haloRing = new THREE.Mesh(
  new THREE.TorusGeometry(100,5,16,100),
  new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
);
haloRing.rotation.x = Math.PI/2;
haloRing.position.set(0,200,-300);
scene.add(haloRing);

// --- Input ---
let moveAxis = {x:0, y:0}, turnAxis = {x:0, y:0};
let jumpPressed = false;

let fireHeld = false;
let rightBWasPressed = false;

// Keyboard (Debug am Desktop)
window.addEventListener('keydown', (e)=>{
  if (e.key==='w') moveAxis.y = -1;
  if (e.key==='s') moveAxis.y =  1;
  if (e.key==='a') moveAxis.x = -1;
  if (e.key==='d') moveAxis.x =  1;
  if (e.key==='ArrowLeft')  turnAxis.x = -1;
  if (e.key==='ArrowRight') turnAxis.x =  1;
  if (e.key===' ') { jumpPressed = true; fireHeld = true; }

  if (e.key === '1') currentWeapon = 0;
  if (e.key === '2') currentWeapon = 1;
});
window.addEventListener('keyup', (e)=>{
  if (e.key==='w' || e.key==='s') moveAxis.y = 0;
  if (e.key==='a' || e.key==='d') moveAxis.x = 0;
  if (e.key==='ArrowLeft' || e.key==='ArrowRight') turnAxis.x = 0;
  if (e.key===' ') { jumpPressed = false; fireHeld = false; }
});

// XR Input per handedness
function readXRInput(session){
  moveAxis.x = moveAxis.y = 0;
  turnAxis.x = turnAxis.y = 0;
  jumpPressed = false;
  fireHeld = false; // wird unten gesetzt, wenn Trigger der aktiven Waffenhand gedrückt ist

  for (const source of session.inputSources){
    if (!source.gamepad) continue;
    const { axes, buttons } = source.gamepad;
    const dead = 0.1;
    // Quest/Wolvic meist: Stick auf axes[2]/[3]
    const axX = Math.abs(axes[2]||0) > dead ? axes[2] : 0;
    const axY = Math.abs(axes[3]||0) > dead ? axes[3] : 0;

    if (source.handedness === 'left'){
      moveAxis.x = axX; moveAxis.y = axY;
    } else if (source.handedness === 'right'){
      turnAxis.x = axX; turnAxis.y = axY;

      // A-Button (id=4) -> Jump (Quest)
      jumpPressed = buttons.some((b,i)=> i===4 ? !!b.pressed : false);

      // B-Button (id=5) -> Waffenwechsel
      const bPressed = (buttons[5] && buttons[5].pressed) || false;
      if (bPressed && !rightBWasPressed) {
        currentWeapon = (currentWeapon + 1) % weapons.length;
      }
      rightBWasPressed = bPressed;
    }

    // Trigger der gewählten Waffenhand
    const trigDown = (buttons[0] && buttons[0].pressed) || false;
    if (source.handedness === settings.weaponHand && trigDown){
      fireHeld = true;
    }
  }
}
function onXRFrame(){
  if (renderer.xr.isPresenting){
    readXRInput(renderer.xr.getSession());
  }
}

// Fallback Events (falls manche Browser selectstart/-end liefern möchten)
controllerLeft.addEventListener('selectstart', ()=> { if (settings.weaponHand==='left')  fireHeld = true;  });
controllerLeft.addEventListener('selectend',   ()=> { if (settings.weaponHand==='left')  fireHeld = false; });
controllerRight.addEventListener('selectstart',()=> { if (settings.weaponHand==='right') fireHeld = true;  });
controllerRight.addEventListener('selectend',  ()=> { if (settings.weaponHand==='right') fireHeld = false; });

// --- Movement / Physics ---
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const moveSpeed = 5;
let playerYRotation = 0;

let vy = 0;
let grounded = false;
let coyoteTimer = 0;
const COYOTE_MAX = 0.1;
const JUMP = 8;
const GRAV = -9.8 * 0.5;
const PROBE = 0.25;

const downRay = new THREE.Raycaster();
const downDir = new THREE.Vector3(0,-1,0);
const upRay   = new THREE.Raycaster();
const upDir   = new THREE.Vector3(0,1,0);

function landIfGroundClose(pos){
  downRay.set(new THREE.Vector3(pos.x, pos.y + 0.2, pos.z), downDir);
  const hits = downRay.intersectObjects(walkableMeshes, true);
  if (!hits.length) return false;
  const hit = hits[0];
  if (vy <= 0 && hit.distance <= (0.2 + PROBE)) {
    pos.y = pos.y + 0.2 - hit.distance;
    vy = 0; grounded = true; coyoteTimer = 0;
    return true;
  }
  return false;
}
function blockCeiling(pos, dt, playerHeight){
  if (vy <= 0) return;
  const headOldY = playerGroup.position.y + playerHeight;
  upRay.set(new THREE.Vector3(pos.x, headOldY, pos.z), upDir);
  upRay.far = (vy * dt) + 0.05;
  const hits = upRay.intersectObjects(staticColliders.map(e=>e.obj), true);
  if (!hits.length) return;
  const hit = hits[0];
  const clampY = hit.point.y - playerHeight;
  if (pos.y > clampY) pos.y = clampY;
  vy = 0;
}

// --- Weapons / Bullets ---
const weapons = [
  { name: 'AR', speed: 16, radius: 0.04, color: 0x00ffea, fireRate: 10 },
  { name: 'BR', speed: 28, radius: 0.03, color: 0xff6a00, fireRate: 5  },
];
let currentWeapon = 0;
let fireCooldown = 0;

const bulletPool = [];
const bullets = [];

function acquireBullet(radius, color){
  let m = bulletPool.pop();
  if (!m){
    m = new THREE.Mesh(
      new THREE.SphereGeometry(radius, 8, 8),
      new THREE.MeshBasicMaterial({ color })
    );
  } else {
    if (!m.geometry.parameters || m.geometry.parameters.radius !== radius){
      m.geometry.dispose();
      m.geometry = new THREE.SphereGeometry(radius, 8, 8);
    }
    m.material.color.setHex(color);
  }
  m.visible = true;
  return m;
}
function releaseBullet(m){
  m.visible = false;
  m.position.set(0,-999,0);
  if (m.velocity) m.velocity.set(0,0,0);
  bulletPool.push(m);
}

// --- Game Update (pro Tick/Fixed-Step) ---
let snapCooldown = 0;            // in Sekunden
function update(dt){
  // Snap Cooldown abbauen
  if (snapCooldown > 0) snapCooldown = Math.max(0, snapCooldown - dt);

  // Turning
  if (settings.turnMode === 'smooth'){
    // kontinuierliches Yaw
    playerYRotation -= turnAxis.x * 0.05;
  } else {
    // Snap-Turn (30°/45°) mit Deadzone & Cooldown
    const dead = 0.35;
    const angle = THREE.MathUtils.degToRad(settings.snapAngleDeg);
    if (snapCooldown === 0){
      if (turnAxis.x <= -dead){
        playerYRotation += angle; // nach links schauen → Drehung + (rechtskoords)
        snapCooldown = 0.22;
      } else if (turnAxis.x >= dead){
        playerYRotation -= angle;
        snapCooldown = 0.22;
      }
    }
  }
  playerGroup.rotation.y = playerYRotation;

  // Move (X/Z)
  if (Math.abs(moveAxis.x) > 0 || Math.abs(moveAxis.y) > 0) {
    direction.set(moveAxis.x, 0, moveAxis.y).normalize();
    const yRot = new THREE.Matrix4().makeRotationY(playerYRotation);
    direction.applyMatrix4(yRot);
    velocity.x = direction.x * moveSpeed;
    velocity.z = direction.z * moveSpeed;
  } else {
    velocity.x = 0; velocity.z = 0;
  }

  // Vertical
  if (!grounded) coyoteTimer = Math.max(0, coyoteTimer - dt);
  if (jumpPressed && (grounded || coyoteTimer > 0)){
    vy = JUMP; grounded = false; coyoteTimer = 0;
  }
  vy += GRAV * dt;

  const newPos = playerGroup.position.clone();
  newPos.x += velocity.x * dt;
  newPos.z += velocity.z * dt;
  newPos.y += vy * dt;

  const playerHeight = 1.6;
  const playerRadius = 0.5;
  let finalPos = newPos.clone();

  // Seiten-Kollisionen (gegen statische Boxen)
  const wallEntries = staticColliders.filter(e => e.obj !== ground && e.obj !== interiorFloor && e.obj !== roof);
  for (const { box } of wallEntries){
    const pBox = {
      minX: finalPos.x - playerRadius,
      maxX: finalPos.x + playerRadius,
      minZ: finalPos.z - playerRadius,
      maxZ: finalPos.z + playerRadius,
      minY: finalPos.y,
      maxY: finalPos.y + playerHeight
    };
    if (pBox.maxX > box.min.x && pBox.minX < box.max.x &&
        pBox.maxZ > box.min.z && pBox.minZ < box.max.z){
      if (finalPos.y < box.max.y && finalPos.y + playerHeight > box.min.y){
        const oldBox = {
          minX: playerGroup.position.x - playerRadius,
          maxX: playerGroup.position.x + playerRadius,
          minZ: playerGroup.position.z - playerRadius,
          maxZ: playerGroup.position.z + playerRadius
        };
        if (!(oldBox.maxX > box.min.x && oldBox.minX < box.max.x)) finalPos.x = playerGroup.position.x;
        if (!(oldBox.maxZ > box.min.z && oldBox.minZ < box.max.z)) finalPos.z = playerGroup.position.z;
      }
    }
  }

  // Decke blocken, dann Bodenfang
  blockCeiling(finalPos, dt, playerHeight);
  const landed = landIfGroundClose(finalPos);
  if (!landed && grounded && vy < 0){ grounded = false; coyoteTimer = COYOTE_MAX; }

  playerGroup.position.copy(finalPos);

  // Shooting (nur aktive Waffenhand)
  fireCooldown = Math.max(0, fireCooldown - dt);
  if (fireHeld && fireCooldown === 0){
    const w = weapons[currentWeapon];
    fireCooldown = 1 / w.fireRate;

    const ctrl = (settings.weaponHand === 'left') ? controllerLeft : controllerRight;
    const bullet = acquireBullet(w.radius, w.color);
    const origin = ctrl.getWorldPosition(new THREE.Vector3());
    const quat   = ctrl.getWorldQuaternion(new THREE.Quaternion());
    bullet.position.copy(origin);
    bullet.quaternion.copy(quat);

    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(quat).normalize();
    bullet.velocity = dir.multiplyScalar(w.speed);
    scene.add(bullet);
    bullets.push(bullet);
  }

  // Bullets
  const staticObjs = staticColliders.map(e => e.obj);
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    const old = b.position.clone();
    b.position.addScaledVector(b.velocity, dt);

    const ray = new THREE.Raycaster(old, b.velocity.clone().normalize());
    const dist = b.velocity.length() * dt;
    ray.far = dist;
    const hits = ray.intersectObjects(staticObjs);
    const hit = hits.length > 0;

    if (hit || b.position.length() > 150){
      scene.remove(b);
      releaseBullet(b);
      bullets.splice(i,1);
    }
  }
}

// --- Minimal In-World HUD (3 Buttons) ---
const hudGroup = new THREE.Group();
hudGroup.position.set(0,-0.2,-0.8); // unterhalb der Sicht
camera.add(hudGroup);

const btnGeo = new THREE.PlaneGeometry(0.24,0.08);
function makeButton(label){
  const c = document.createElement('canvas'); c.width=256; c.height=128;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#202020'; ctx.fillRect(0,0,c.width,c.height);
  ctx.strokeStyle = '#404040'; ctx.lineWidth = 6; ctx.strokeRect(4,4,c.width-8,c.height-8);
  ctx.fillStyle = '#ffffff'; ctx.font = 'bold 36px system-ui,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(label, c.width/2, c.height/2);
  const tex = new THREE.CanvasTexture(c);
  return new THREE.Mesh(btnGeo, new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
}
const btnTurnMode = makeButton('Turn: Smooth');
const btnSnap     = makeButton('Snap: 30°');
const btnHand     = makeButton('Hand: Left');

btnTurnMode.position.set(-0.26, 0, 0);
btnSnap.position.set(0, 0, 0);
btnHand.position.set(0.26, 0, 0);

hudGroup.add(btnTurnMode, btnSnap, btnHand);

// einfacher Ray vom rechten Controller für Button-Klicks
const uiRay = new THREE.Raycaster();
function updateButtonTextures(){
  // Turn
  {
    const c = btnTurnMode.material.map.image;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle = '#202020'; ctx.fillRect(0,0,c.width,c.height);
    ctx.strokeStyle = '#404040'; ctx.lineWidth = 6; ctx.strokeRect(4,4,c.width-8,c.height-8);
    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 36px system-ui,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(`Turn: ${settings.turnMode==='smooth'?'Smooth':'Snap'}`, c.width/2, c.height/2);
    btnTurnMode.material.map.needsUpdate = true;
  }
  // Snap
  {
    const c = btnSnap.material.map.image;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle = '#202020'; ctx.fillRect(0,0,c.width,c.height);
    ctx.strokeStyle = '#404040'; ctx.lineWidth = 6; ctx.strokeRect(4,4,c.width-8,c.height-8);
    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 36px system-ui,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(`Snap: ${settings.snapAngleDeg}°`, c.width/2, c.height/2);
    btnSnap.material.map.needsUpdate = true;
  }
  // Hand
  {
    const c = btnHand.material.map.image;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle = '#202020'; ctx.fillRect(0,0,c.width,c.height);
    ctx.strokeStyle = '#404040'; ctx.lineWidth = 6; ctx.strokeRect(4,4,c.width-8,c.height-8);
    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 36px system-ui,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const cap = settings.weaponHand==='left'?'Left':'Right';
    ctx.fillText(`Hand: ${cap}`, c.width/2, c.height/2);
    btnHand.material.map.needsUpdate = true;
  }
}
updateButtonTextures();

// Klick-Handling (selectstart auf rechter Hand)
controllerRight.addEventListener('selectstart', ()=>{
  // Ray aus rechter Hand
  const origin = controllerRight.getWorldPosition(new THREE.Vector3());
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(controllerRight.getWorldQuaternion(new THREE.Quaternion())).normalize();
  uiRay.set(origin, dir);
  const hits = uiRay.intersectObjects([btnTurnMode, btnSnap, btnHand], false);
  if (hits.length){
    const obj = hits[0].object;
    if (obj === btnTurnMode){
      settings.turnMode = (settings.turnMode==='smooth') ? 'snap' : 'smooth';
      // Sync ins Overlay
      ovTurnMode.value = settings.turnMode;
    } else if (obj === btnSnap){
      settings.snapAngleDeg = (settings.snapAngleDeg===30) ? 45 : 30;
      ovSnapAngle.value = String(settings.snapAngleDeg);
    } else if (obj === btnHand){
      attachGunTo(settings.weaponHand==='left' ? 'right' : 'left');
      ovWeaponHand.value = settings.weaponHand;
    }
    updateButtonTextures();
  }
});

// --- Fixed-Timestep Loop (A) ---
const FIXED_DT = 1/60;       // 60 Hz
const MAX_STEPS = 5;         // Spiral-of-death Guard
let accumulator = 0;

function onRenderFrame(){
  const rawDt = clock.getDelta();
  // clamp dt (z.B. beim Tab-Wechsel)
  const dt = Math.min(rawDt, 0.25);
  onXRFrame();

  accumulator += dt;
  let steps = 0;
  while (accumulator >= FIXED_DT && steps < MAX_STEPS){
    update(FIXED_DT);
    accumulator -= FIXED_DT;
    steps++;
  }

  renderer.render(scene, camera);
}

// --- Resize ---
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// --- Start / Attach gun initial ---
attachGunTo(settings.weaponHand);

// --- START LOOP ---
renderer.setAnimationLoop(onRenderFrame);
</script>
</body>
</html>
