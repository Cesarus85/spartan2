<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>WebXR Halo-Style Shooter ‚Äì Fix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0d10; }
    #ui {
      position: absolute; left: 12px; top: 12px; color: #dfe8ff; font-family: system-ui, sans-serif;
      background: rgba(10,12,16,.6); padding: 10px 12px; border-radius: 10px; backdrop-filter: blur(4px);
      box-shadow: 0 6px 18px rgba(0,0,0,.35); max-width: 420px; line-height: 1.35; z-index: 10;
    }
    #ui small { opacity: .85; display: block; margin-top: 6px; }
    #stats { position: absolute; right: 12px; top: 12px; color: #cfe; font: 12px/1.2 monospace; white-space: pre; z-index: 10; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <b>Halo-Style Shooter (Grundger√ºst)</b>
    <small>
      üéØ Linker Trigger: Schie√üen ‚Ä¢ üïπÔ∏è L-Stick: Vor/Zur√ºck/Strafe ‚Ä¢ üïπÔ∏è R-Stick: Drehen ‚Ä¢ üÖ∞Ô∏è Rechts: Springen
      <br/>üåç Map ~20√ó20, Festung mittig (Tor offen) ‚Ä¢ üåå Halo-Ring am Himmel
    </small>
  </div>
  <div id="stats">Init‚Ä¶</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
    import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js";
    import { XRControllerModelFactory } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/XRControllerModelFactory.js";

    const statsDiv = document.getElementById('stats');

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // VR Button (ohne requiredFeatures, daf√ºr optionalFeatures breit)
    const btn = VRButton.createButton(renderer, {
      optionalFeatures: ["local-floor","bounded-floor","hand-tracking","layers"]
    });
    document.body.appendChild(btn);

    // Scene / Camera / Player
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x07090c);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 200);
    const player = new THREE.Group();
    scene.add(player);
    player.add(camera);

    // Desktop-Startpose (Vorschau)
    player.position.set(0, 0, 8.5);
    player.rotation.set(0, Math.PI, 0);

    // Lights
    const hemi = new THREE.HemisphereLight(0xbcd2ff, 0x101318, .55);
    scene.add(hemi);
    const dirLight = new THREE.DirectionalLight(0xffffff, .85);
    dirLight.position.set(12, 18, 7);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(1024, 1024);
    dirLight.shadow.camera.left = -22; dirLight.shadow.camera.right = 22;
    dirLight.shadow.camera.top = 22; dirLight.shadow.camera.bottom = -22;
    scene.add(dirLight);

    // Halo-Ring
    const haloRing = new THREE.Mesh(
      new THREE.TorusGeometry(40, 0.6, 16, 180),
      new THREE.MeshStandardMaterial({ color: 0x6ea8ff, emissive: 0x143a62, emissiveIntensity: 0.4, metalness: 0.2, roughness: 0.6 })
    );
    haloRing.position.set(0, 30, -10);
    haloRing.rotation.set(Math.PI * 0.08, Math.PI * 0.15, 0);
    scene.add(haloRing);

    // Ground
    const MAP_SIZE = 20;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE),
      new THREE.MeshStandardMaterial({ color: 0x1a1f2a, roughness: 1.0, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Hindernisse
    const obstacles = [];
    function addBlock(x, z, w, h, d, color = 0x1f2633) {
      const m = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        new THREE.MeshStandardMaterial({ color, roughness: 0.9, metalness: 0.05 })
      );
      m.position.set(x, h/2, z);
      m.castShadow = true; m.receiveShadow = true;
      scene.add(m); obstacles.push(m); return m;
    }
    addBlock(-6, -4, 2, 1.2, 2);
    addBlock(5, 3, 3, 0.7, 3, 0x223044);
    addBlock(-2, 6, 2, 1.6, 4);
    addBlock(7, -6, 2, 2.2, 2, 0x24334a);

    // Festung
    const fortress = new THREE.Group(); scene.add(fortress);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x121720, roughness: 0.95, metalness: 0.05 });
    const wallThickness = 0.6, fortSize = 8, fortHeight = 5;
    [
      { pos:[-fortSize/2, fortHeight/2, 0], size:[wallThickness, fortHeight, fortSize] },
      { pos:[ fortSize/2, fortHeight/2, 0], size:[wallThickness, fortHeight, fortSize] },
      { pos:[0, fortHeight/2, -fortSize/2], size:[fortSize, fortHeight, wallThickness] },
      { pos:[-2.8, fortHeight/2,  fortSize/2], size:[fortSize/2 - 1.5, fortHeight, wallThickness] },
      { pos:[ 2.8, fortHeight/2,  fortSize/2], size:[fortSize/2 - 1.5, fortHeight, wallThickness] },
    ].forEach(s=>{
      const w = new THREE.Mesh(new THREE.BoxGeometry(...s.size), wallMat);
      w.position.set(...s.pos); w.castShadow = true; w.receiveShadow = true;
      fortress.add(w); obstacles.push(w);
    });
    for (let i=0;i<4;i++){
      const c = addBlock((i<2?-1:1)*2.2, (i%2?-1:1)*2.2, 0.8, 3.6, 0.8, 0x0f141d);
      fortress.add(c);
    }

    // Spartan Torso (sichtbar)
    const spartan = new THREE.Group();
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.45,0.2), new THREE.MeshStandardMaterial({ color: 0x244b35, roughness: 0.8, metalness: 0.2 }));
    torso.position.set(0,-0.15,-0.35); torso.castShadow = true;
    const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.11,0.14,8), new THREE.MeshStandardMaterial({ color: 0x1d2f27, roughness: 0.8 }));
    neck.position.set(0,0.05,-0.34);
    spartan.add(torso, neck);
    camera.add(spartan);

    // Controller
    const controllerModelFactory = new XRControllerModelFactory();
    let leftCtrl=null,rightCtrl=null,leftGrip=null,rightGrip=null;
    function makeController(i){
      const c = renderer.xr.getController(i);
      c.addEventListener('connected', e=>{ const h=e.data.handedness; if(h==='left')leftCtrl=c; if(h==='right')rightCtrl=c; });
      c.addEventListener('disconnected', ()=>{ if(leftCtrl===c)leftCtrl=null; if(rightCtrl===c)rightCtrl=null; });
      player.add(c); return c;
    }
    function makeGrip(i){
      const g = renderer.xr.getControllerGrip(i);
      g.add(controllerModelFactory.createControllerModel(g));
      g.addEventListener('connected', e=>{ const h=e.data.handedness; if(h==='left')leftGrip=g; if(h==='right')rightGrip=g; });
      g.addEventListener('disconnected', ()=>{ if(leftGrip===g)leftGrip=null; if(rightGrip===g)rightGrip=null; });
      player.add(g); return g;
    }
    makeController(0); makeController(1); makeGrip(0); makeGrip(1);

    // Linke-Hand-Gewehr (vereinfacht)
    const rifle = new THREE.Group();
    (function(){
      const base = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.08,0.10), new THREE.MeshStandardMaterial({ color: 0x2b2f36, roughness:.7, metalness:.3 }));
      const stock= new THREE.Mesh(new THREE.BoxGeometry(0.18,0.09,0.12), new THREE.MeshStandardMaterial({ color: 0x1e232b, roughness:.8 }));
      const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.018,0.28,12), new THREE.MeshStandardMaterial({ color: 0x444b55, metalness:.6, roughness:.4 }));
      barrel.rotation.z = Math.PI/2; barrel.position.set(0.34,0,0);
      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.06), new THREE.MeshStandardMaterial({ color: 0x20242b, roughness:.8 }));
      grip.position.set(-0.02,-0.09,0.02); grip.rotation.z = -0.35;
      rifle.add(base,stock,barrel,grip); rifle.castShadow = true;
    })();
    const rifleHolder = new THREE.Group();

    renderer.xr.addEventListener('sessionstart', ()=>{
      setTimeout(()=>{
        if (leftGrip && !rifleHolder.parent){
          rifleHolder.add(rifle);
          rifle.position.set(0.02,-0.03,-0.03);
          rifle.rotation.set(0, Math.PI, 0.12);
          leftGrip.add(rifleHolder);
        }
      }, 300);
      // Startpose im XR
      player.position.set(0, 0, 8.5);
      player.rotation.set(0, Math.PI, 0);
    });

    // Projektile
    const projectiles=[]; const MAX_PROJECTILES=40;
    function spawnProjectile(origin, dir){
      const p = new THREE.Mesh(
        new THREE.SphereGeometry(0.02, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0x78b3ff, emissive: 0x114477, emissiveIntensity: 0.5 })
      );
      p.position.copy(origin);
      p.castShadow = true;
      p.userData = { vel: dir.clone().multiplyScalar(18), life: 2.5 };
      scene.add(p); projectiles.push(p);
      if (projectiles.length>MAX_PROJECTILES){ const old=projectiles.shift(); scene.remove(old); old.geometry.dispose(); old.material.dispose(); }
    }

    // Movement
    let velocityY=0;
    const GRAVITY=4.0, JUMP_VELOCITY=2.2, MOVE_SPEED=2.5, ROT_SPEED=2.4, DEADZONE=0.18;
    let jumpPressedPrev=false, triggerPressedPrev=false;

    function getGamepad(ctrl){ return (ctrl && ctrl.gamepad) ? ctrl.gamepad : null; }
    const dz = v=> Math.abs(v)<DEADZONE?0:v;

    const tmpBox = new THREE.Box3();
    const playerRadius = 0.25;
    function collideAndSlide(nextPos){
      const half = MAP_SIZE*0.5 - 0.2;
      nextPos.x = Math.max(-half, Math.min(half, nextPos.x));
      nextPos.z = Math.max(-half, Math.min(half, nextPos.z));
      const playerBox = new THREE.Box3(
        new THREE.Vector3(nextPos.x - playerRadius, nextPos.y, nextPos.z - playerRadius),
        new THREE.Vector3(nextPos.x + playerRadius, nextPos.y + 1.7, nextPos.z + playerRadius)
      );
      for (const o of obstacles){
        tmpBox.setFromObject(o);
        if (tmpBox.intersectsBox(playerBox)){
          const c = tmpBox.getCenter(new THREE.Vector3());
          const dx = nextPos.x - c.x, dzv = nextPos.z - c.z;
          if (Math.abs(dx) > Math.abs(dzv)) nextPos.x = (dx>0) ? tmpBox.max.x + playerRadius : tmpBox.min.x - playerRadius;
          else nextPos.z = (dzv>0) ? tmpBox.max.z + playerRadius : tmpBox.min.z - playerRadius;
        }
      }
      return nextPos;
    }

    // Grid (Orientierung)
    const grid = new THREE.GridHelper(MAP_SIZE, MAP_SIZE, 0x234, 0x123);
    grid.position.y = 0.002; grid.material.opacity = 0.25; grid.material.transparent = true; scene.add(grid);

    // Loop
    const forward = new THREE.Vector3(), right = new THREE.Vector3(), tmp = new THREE.Vector3();
    const projDir = new THREE.Vector3(), muzzle = new THREE.Vector3();
    let prevT = 0; // <-- FIX: dt via t

    renderer.setAnimationLoop((t, frame)=>{
      const dt = Math.min(0.033, ((t - prevT) || 16.6) / 1000);
      prevT = t;

      // Stats
      statsDiv.textContent = `XR: ${renderer.xr.isPresenting ? 'on' : 'off'}\nSupport: ${'xr' in navigator ? 'yes' : 'no'}\nProjectiles: ${projectiles.length}`;

      // Input
      const lgp = getGamepad(leftCtrl), rgp = getGamepad(rightCtrl);
      let lx=0, ly=0, rx=0, trigger=false, jump=false;

      if (lgp?.axes?.length>=2){ lx = dz(lgp.axes[0]); ly = dz(lgp.axes[1]); }
      if (rgp?.axes?.length>=2){ rx = dz(rgp.axes[2] ?? rgp.axes[0]); }
      if (leftCtrl?.gamepad?.buttons?.length) trigger = !!leftCtrl.gamepad.buttons[0]?.pressed;
      if (rightCtrl?.gamepad?.buttons?.length>4) jump = !!rightCtrl.gamepad.buttons[4]?.pressed; // Quest A

      // Rotation
      player.rotation.y -= rx * ROT_SPEED * dt;

      // Move (relativ zur Blickrichtung, Y=0)
      const camDir = camera.getWorldDirection(forward).setY(0).normalize();
      right.copy(camDir).cross(new THREE.Vector3(0,1,0)).normalize();
      const moveVec = tmp.set(0,0,0).addScaledVector(camDir, -ly).addScaledVector(right, lx);
      if (moveVec.lengthSq()>1e-6) moveVec.normalize().multiplyScalar(MOVE_SPEED*dt);

      // Gravity / Jump
      let onGround = (player.position.y <= 0.0001);
      if (onGround) player.position.y = 0;
      if (jump && !jumpPressedPrev && onGround){ velocityY = JUMP_VELOCITY; onGround=false; }
      velocityY -= GRAVITY * dt;
      player.position.y = Math.max(0, player.position.y + velocityY * dt);
      if (player.position.y === 0 && velocityY < 0) velocityY = 0;
      jumpPressedPrev = jump;

      // Kollisionsanwendung
      const nextPos = player.position.clone().add(moveVec);
      collideAndSlide(nextPos);
      player.position.x = nextPos.x; player.position.z = nextPos.z;

      // Schie√üen (Kante)
      if (trigger && !triggerPressedPrev && leftGrip){
        leftGrip.getWorldPosition(muzzle);
        leftGrip.getWorldDirection(projDir).normalize();
        spawnProjectile(muzzle.addScaledVector(projDir, 0.35), projDir);
      }
      triggerPressedPrev = trigger;

      // Projektile
      for (let i=projectiles.length-1;i>=0;i--){
        const p = projectiles[i];
        p.position.addScaledVector(p.userData.vel, dt);
        p.userData.life -= dt;
        if (p.position.y < 0.01 || p.userData.life <= 0){
          scene.remove(p); p.geometry.dispose(); p.material.dispose(); projectiles.splice(i,1);
        }
      }

      // Deko
      haloRing.rotation.y += 0.02 * dt;

      renderer.render(scene, camera);
    });

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Referenzraum
    renderer.xr.setReferenceSpaceType("local-floor");
  </script>
</body>
</html>
