<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Halo-Style WebXR Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

// --- Renderer / Scene / Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));
const clock = new THREE.Clock();

// --- Lights ---
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5,10,5);
scene.add(dirLight);

// --- Player rig ---
const playerGroup = new THREE.Group();
// Spawn auf dem Dach wie bisher
playerGroup.position.set(0, 3.25 + 1.6, 0);
scene.add(playerGroup);
playerGroup.add(camera);

// Spartan-„Body“ (einfach)
const playerBody = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
  new THREE.MeshStandardMaterial({ color: 0x006400 })
);
playerBody.position.y = -1.6;
playerGroup.add(playerBody);

// Controller + Grips
const controllerLeft  = renderer.xr.getController(0);
const controllerRight = renderer.xr.getController(1);
playerGroup.add(controllerLeft, controllerRight);
const gripLeft  = renderer.xr.getControllerGrip(0);
const gripRight = renderer.xr.getControllerGrip(1);
playerGroup.add(gripLeft, gripRight);

// „Gun“ an die linke Hand (wie gehabt)
const gun = new THREE.Mesh(
  new THREE.BoxGeometry(0.1,0.1,0.5),
  new THREE.MeshStandardMaterial({ color: 0x808080 })
);
gun.position.set(0,-0.1,-0.3);
controllerLeft.add(gun);

// --- Level: Boden, Hindernisse, Festung ---
const collidableObjects = [];

const groundGeometry = new THREE.PlaneGeometry(20,20,20,20);
groundGeometry.rotateX(-Math.PI/2);
// leichte Unebenheiten
const verts = groundGeometry.attributes.position.array;
for (let i=2; i<verts.length; i+=3) {
  verts[i] += Math.random()*0.5 - 0.25;
}
groundGeometry.attributes.position.needsUpdate = true;
groundGeometry.computeVertexNormals();
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
scene.add(ground);

// Hindernisse
for (let i=0; i<10; i++){
  const w = new THREE.Mesh(
    new THREE.BoxGeometry(Math.random()*2+1, Math.random()*2+1, Math.random()*2+1),
    new THREE.MeshStandardMaterial({ color: 0xA9A9A9 })
  );
  w.position.set(Math.random()*20-10, w.geometry.parameters.height/2, Math.random()*20-10);
  scene.add(w);
  collidableObjects.push(w);
}

// Festung
const fortressGroup = new THREE.Group();
const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

const wall1Left = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Left.position.set(-1.75,1.5,2.5);
fortressGroup.add(wall1Left); collidableObjects.push(wall1Left);

const wall1Right = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Right.position.set(1.75,1.5,2.5);
fortressGroup.add(wall1Right); collidableObjects.push(wall1Right);

const lintel = new THREE.Mesh(new THREE.BoxGeometry(2,0.5,0.5), wallMat);
lintel.position.set(0,2.75,2.5);
fortressGroup.add(lintel); collidableObjects.push(lintel);

const wallBack = new THREE.Mesh(new THREE.BoxGeometry(5,3,0.5), wallMat);
wallBack.position.set(0,1.5,-2.5);
fortressGroup.add(wallBack); collidableObjects.push(wallBack);

const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallLeft.position.set(2.5,1.5,0);
fortressGroup.add(wallLeft); collidableObjects.push(wallLeft);

const wallRight = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallRight.position.set(-2.5,1.5,0);
fortressGroup.add(wallRight); collidableObjects.push(wallRight);

const roof = new THREE.Mesh(new THREE.BoxGeometry(5,0.5,5), wallMat);
roof.position.set(0,3.25,0);
fortressGroup.add(roof); collidableObjects.push(roof);

const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4,0.1,4), groundMaterial);
interiorFloor.position.set(0,0.05,0);
fortressGroup.add(interiorFloor); collidableObjects.push(interiorFloor);

scene.add(fortressGroup);

// Boden gehört auch zu den möglichen Treffern
collidableObjects.push(ground);

// Himmel + Halo-Ring
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(500,32,32),
  new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide })
);
scene.add(sky);
const haloRing = new THREE.Mesh(
  new THREE.TorusGeometry(100,5,16,100),
  new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
);
haloRing.rotation.x = Math.PI/2;
haloRing.position.set(0,200,-300);
scene.add(haloRing);

// --- Input ---
let moveAxis = {x:0, y:0}, turnAxis = {x:0, y:0};
let jumpPressed = false;

window.addEventListener('keydown', (e)=>{
  if (e.key==='w') moveAxis.y = -1;
  if (e.key==='s') moveAxis.y =  1;
  if (e.key==='a') moveAxis.x = -1;
  if (e.key==='d') moveAxis.x =  1;
  if (e.key==='ArrowLeft')  turnAxis.x = -1;
  if (e.key==='ArrowRight') turnAxis.x =  1;
  if (e.key===' ') jumpPressed = true;
});
window.addEventListener('keyup', (e)=>{
  if (e.key==='w' || e.key==='s') moveAxis.y = 0;
  if (e.key==='a' || e.key==='d') moveAxis.x = 0;
  if (e.key==='ArrowLeft' || e.key==='ArrowRight') turnAxis.x = 0;
  if (e.key===' ') jumpPressed = false;
});

function readXRInput(session){
  moveAxis.x = moveAxis.y = 0;
  turnAxis.x = turnAxis.y = 0;
  jumpPressed = false;

  for (const source of session.inputSources){
    if (!source.gamepad) continue;
    const { axes, buttons } = source.gamepad;
    const dead = 0.1;
    const axX = Math.abs(axes[2]||0) > dead ? axes[2] : 0;
    const axY = Math.abs(axes[3]||0) > dead ? axes[3] : 0;

    if (source.handedness === 'left'){
      moveAxis.x = axX; moveAxis.y = axY;
    } else if (source.handedness === 'right'){
      turnAxis.x = axX; turnAxis.y = axY;
      // A-Button häufig index 4 (Quest) – hier als Heuristik:
      jumpPressed = buttons.some((b,i)=> i===4 ? b.pressed : false);
    }
  }
}

function onXRFrame(){
  if (renderer.xr.isPresenting){
    readXRInput(renderer.xr.getSession());
  }
}

// --- Movement / Physics ---
const velocity = new THREE.Vector3();   // NUR für X/Z
const direction = new THREE.Vector3();
const moveSpeed = 5;
let playerYRotation = 0;

// Vertikal-Physik (Jump-Fix)
let vy = 0;
let grounded = false;
let coyoteTimer = 0;
const COYOTE_MAX = 0.1;     // 100 ms Gnadenzeit
const JUMP = 8;             // Sprung-Impuls
const GRAV = -9.8 * 0.5;    // halbe Erdanziehung (wie vorher)
const PROBE = 0.25;         // Snap-Distanz

const downRay = new THREE.Raycaster();
const downDir = new THREE.Vector3(0,-1,0);

function landIfGroundClose(pos){
  // leicht oberhalb casten, damit wir zuverlässig treffen
  downRay.set(new THREE.Vector3(pos.x, pos.y + 0.2, pos.z), downDir);
  const hits = downRay.intersectObjects([ground, interiorFloor, roof], true);
  if (!hits.length) return false;
  const hit = hits[0];

  // Nur beim FALLEN und wenn Boden wirklich nah ist „einrasten“
  if (vy <= 0 && hit.distance <= (0.2 + PROBE)) {
    pos.y = pos.y + 0.2 - hit.distance;
    vy = 0;
    grounded = true;
    coyoteTimer = 0;
    return true;
  }
  return false;
}

// --- Shooting ---
const bullets = [];
controllerLeft.addEventListener('selectstart', ()=>{
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.05,8,8),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
  );
  bullet.position.copy(controllerLeft.getWorldPosition(new THREE.Vector3()));
  bullet.quaternion.copy(controllerLeft.getWorldQuaternion(new THREE.Quaternion()));
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(bullet.quaternion);
  bullet.velocity = dir.multiplyScalar(10);
  scene.add(bullet);
  bullets.push(bullet);
});

// --- Update ---
function update(dt){
  // Turning
  playerYRotation -= turnAxis.x * 0.05;
  playerGroup.rotation.y = playerYRotation;

  // Horizontal movement (lokal)
  if (Math.abs(moveAxis.x) > 0 || Math.abs(moveAxis.y) > 0) {
    direction.set(moveAxis.x, 0, moveAxis.y).normalize();
    const yRot = new THREE.Matrix4().makeRotationY(playerYRotation);
    direction.applyMatrix4(yRot);
    velocity.x = direction.x * moveSpeed;
    velocity.z = direction.z * moveSpeed;
  } else {
    velocity.x = 0; velocity.z = 0;
  }

  // ---- Vertikal: Reihenfolge wichtig ----
  // Coyote-Zeit fortschreiben
  if (!grounded) coyoteTimer = Math.max(0, coyoteTimer - dt);

  // Jump (vor Gravity / vor Landen)
  if (jumpPressed && (grounded || coyoteTimer > 0)){
    vy = JUMP;
    grounded = false;
    coyoteTimer = 0;
  }

  // Gravity
  vy += GRAV * dt;

  // Position vorschlagen
  const newPos = playerGroup.position.clone();
  newPos.x += velocity.x * dt;
  newPos.z += velocity.z * dt;
  newPos.y += vy * dt;

  // --- Kollisionen horizontal (Wände/Hindernisse), Boden/Decken separat ---
  const playerHeight = 1.6;
  const playerRadius = 0.5;
  let finalPos = newPos.clone();

  const wallObjects = collidableObjects.filter(o => o !== ground && o !== interiorFloor && o !== roof);
  for (const obj of wallObjects){
    const box = new THREE.Box3().setFromObject(obj);

    const pBox = {
      minX: finalPos.x - playerRadius,
      maxX: finalPos.x + playerRadius,
      minZ: finalPos.z - playerRadius,
      maxZ: finalPos.z + playerRadius,
      minY: finalPos.y,
      maxY: finalPos.y + playerHeight
    };

    // horizontaler Überlappungs-Test
    if (pBox.maxX > box.min.x && pBox.minX < box.max.x &&
        pBox.maxZ > box.min.z && pBox.minZ < box.max.z){

      // von unten anstoßen (Decke)
      if (vy > 0 &&
          playerGroup.position.y + playerHeight <= box.min.y &&
          finalPos.y + playerHeight >= box.min.y){
        finalPos.y = box.min.y - playerHeight;
        vy = 0;
      }
      // Seiten-Kollision blocken
      else if (finalPos.y < box.max.y && finalPos.y + playerHeight > box.min.y){
        const oldBox = {
          minX: playerGroup.position.x - playerRadius,
          maxX: playerGroup.position.x + playerRadius,
          minZ: playerGroup.position.z - playerRadius,
          maxZ: playerGroup.position.z + playerRadius
        };
        if (!(oldBox.maxX > box.min.x && oldBox.minX < box.max.x)) {
          finalPos.x = playerGroup.position.x;
        }
        if (!(oldBox.maxZ > box.min.z && oldBox.minZ < box.max.z)) {
          finalPos.z = playerGroup.position.z;
        }
      }
    }
  }

  // Bodenfang nur beim Fallen & nahe am Boden
  const landed = landIfGroundClose(finalPos);
  if (!landed && grounded && vy < 0){
    // wir waren grounded, sind jetzt in der Luft -> Coyote starten
    grounded = false;
    coyoteTimer = COYOTE_MAX;
  }

  // Position anwenden
  playerGroup.position.copy(finalPos);

  // --- Bullets updaten (rückwärts iterieren, robust gegen splice) ---
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    const old = b.position.clone();
    b.position.add(b.velocity.clone().multiplyScalar(dt));

    const ray = new THREE.Raycaster(old, b.velocity.clone().normalize());
    const hits = ray.intersectObjects(collidableObjects);
    let hit = false;
    for (const h of hits){
      if (h.distance <= b.velocity.length() * dt) { hit = true; break; }
    }
    if (hit || b.position.length() > 100){
      scene.remove(b);
      bullets.splice(i,1);
    }
  }
}

// --- Animation Loop ---
renderer.setAnimationLoop(()=>{
  const dt = Math.min(clock.getDelta(), 1/30);
  onXRFrame();
  update(dt);
  renderer.render(scene, camera);
});

// --- Resize ---
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
