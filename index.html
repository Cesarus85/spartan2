<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Halo-Style WebXR Shooter</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

// --- Renderer / Scene / Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));
const clock = new THREE.Clock();

// --- Mini-Grafik-Pass ---
scene.fog = new THREE.Fog(0x88b7e0, 20, 120); // dezent
const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x403020, 0.7);
scene.add(hemi);

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(5,12,6);
scene.add(dirLight);

// --- Player rig ---
const playerGroup = new THREE.Group();
playerGroup.position.set(0, 3.25 + 1.6, 0);
scene.add(playerGroup);
playerGroup.add(camera);

const playerBody = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
  new THREE.MeshStandardMaterial({ color: 0x006400 })
);
playerBody.position.y = -1.6;
playerGroup.add(playerBody);

// Controller + Grips
const controllerLeft  = renderer.xr.getController(0);
const controllerRight = renderer.xr.getController(1);
playerGroup.add(controllerLeft, controllerRight);
const gripLeft  = renderer.xr.getControllerGrip(0);
const gripRight = renderer.xr.getControllerGrip(1);
playerGroup.add(gripLeft, gripRight);

// „Gun“ (links)
const gun = new THREE.Mesh(
  new THREE.BoxGeometry(0.1,0.1,0.5),
  new THREE.MeshStandardMaterial({ color: 0x808080 })
);
gun.position.set(0,-0.1,-0.3);
controllerLeft.add(gun);

// --- Level helpers ---
const staticColliders = []; // { obj, box }
const walkableMeshes  = [];
function addStaticCollider(obj){ const box = new THREE.Box3().setFromObject(obj); staticColliders.push({ obj, box }); }
function addWalkable(obj){ walkableMeshes.push(obj); }

// --- Ground ---
const groundGeometry = new THREE.PlaneGeometry(20,20,20,20);
groundGeometry.rotateX(-Math.PI/2);
// leichte Unebenheiten + minimaler Farbverlauf
const verts = groundGeometry.attributes.position.array;
for (let i=2; i<verts.length; i+=3) verts[i] += Math.random()*0.5 - 0.25;
groundGeometry.attributes.position.needsUpdate = true;
groundGeometry.computeVertexNormals();

const groundMaterial = new THREE.MeshStandardMaterial({
  color: 0x8B6b3a, roughness: 0.9, metalness: 0.0, side: THREE.DoubleSide
});
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
scene.add(ground); addStaticCollider(ground); addWalkable(ground);

// --- Fortress (erst Festung, dann Hindernisse) ---
const fortressGroup = new THREE.Group();
const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.05 });

const wall1Left = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Left.position.set(-1.75,1.5,2.5);
fortressGroup.add(wall1Left); addStaticCollider(wall1Left);

const wall1Right = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,0.5), wallMat);
wall1Right.position.set(1.75,1.5,2.5);
fortressGroup.add(wall1Right); addStaticCollider(wall1Right);

const lintel = new THREE.Mesh(new THREE.BoxGeometry(2,0.5,0.5), wallMat);
lintel.position.set(0,2.75,2.5);
fortressGroup.add(lintel); addStaticCollider(lintel);

const wallBack = new THREE.Mesh(new THREE.BoxGeometry(5,3,0.5), wallMat);
wallBack.position.set(0,1.5,-2.5);
fortressGroup.add(wallBack); addStaticCollider(wallBack);

const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallLeft.position.set(2.5,1.5,0);
fortressGroup.add(wallLeft); addStaticCollider(wallLeft);

const wallRight = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,5), wallMat);
wallRight.position.set(-2.5,1.5,0);
fortressGroup.add(wallRight); addStaticCollider(wallRight);

const roof = new THREE.Mesh(new THREE.BoxGeometry(5,0.5,5), wallMat);
roof.position.set(0,3.25,0);
fortressGroup.add(roof); addStaticCollider(roof); addWalkable(roof);

const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4,0.1,4), groundMaterial);
interiorFloor.position.set(0,0.05,0);
fortressGroup.add(interiorFloor); addStaticCollider(interiorFloor); addWalkable(interiorFloor);

scene.add(fortressGroup);

// --- No-Spawn-Zonen (Fortress + Tor-Korridor) ---
const forbiddenZones = [
  new THREE.Box3(new THREE.Vector3(-2.7,0.0,-2.7), new THREE.Vector3(2.7,4.5,2.9)),
  new THREE.Box3(new THREE.Vector3(-1.2,0.0, 1.2), new THREE.Vector3(1.2,3.0,4.0))
];

function intersectsForbidden(box){ for (const f of forbiddenZones){ if (box.intersectsBox(f)) return true; } return false; }
function placeBlockAvoiding(block, attempts=60){
  const size = block.geometry.parameters; const hx=(size.width||1)/2, hy=(size.height||1)/2, hz=(size.depth||1)/2;
  for (let i=0;i<attempts;i++){
    const x = Math.random()*20-10, z = Math.random()*20-10, y = hy;
    const candidate = new THREE.Box3(new THREE.Vector3(x-hx,0,z-hz), new THREE.VectorVector3?.noop);
  }
}

// (kleiner Fix: VectorVector3?.noop existiert nicht – richtige impl unten)
function placeBlock(block, attempts=60){
  const size = block.geometry.parameters;
  const hx=(size.width||1)/2, hy=(size.height||1)/2, hz=(size.depth||1)/2;
  for (let i=0;i<attempts;i++){
    const x = Math.random()*20-10;
    const z = Math.random()*20-10;
    const y = hy;
    const min = new THREE.Vector3(x-hx, 0,   z-hz);
    const max = new THREE.Vector3(x+hx, y*2, z+hz);
    const candidate = new THREE.Box3(min, max);
    if (!intersectsForbidden(candidate)){
      block.position.set(x,y,z);
      return true;
    }
  }
  return false;
}

// Hindernisse
for (let i=0; i<10; i++){
  const w = new THREE.Mesh(
    new THREE.BoxGeometry(Math.random()*2+1, Math.random()*2+1, Math.random()*2+1),
    new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.8, metalness: 0.05 })
  );
  if (!placeBlock(w)){
    w.position.set(12 + Math.random()*6, (w.geometry.parameters.height||1)/2, 12 + Math.random()*6);
  }
  scene.add(w);
  addStaticCollider(w);
  addWalkable(w);
}

// --- Himmel + Ring ---
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(500,32,32),
  new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide, fog: false })
);
scene.add(sky);
const haloRing = new THREE.Mesh(
  new THREE.TorusGeometry(100,5,16,100),
  new THREE.MeshBasicMaterial({ color: 0xFFFFFF, fog: false })
);
haloRing.rotation.x = Math.PI/2;
haloRing.position.set(0,200,-300);
scene.add(haloRing);

// --- Input ---
let moveAxis = {x:0, y:0}, turnAxis = {x:0, y:0};
let jumpPressed = false;
let fireHeld = false;
let rightBWasPressed = false;

// Snap-Turn / Smooth Toggle
let snapTurnEnabled = true;
const SNAP_ANGLE = THREE.MathUtils.degToRad(30);
let snapDebounce = 0;

// Keyboard
window.addEventListener('keydown', (e)=>{
  if (e.key==='w') moveAxis.y = -1;
  if (e.key==='s') moveAxis.y =  1;
  if (e.key==='a') moveAxis.x = -1;
  if (e.key==='d') moveAxis.x =  1;
  if (e.key==='ArrowLeft')  turnAxis.x = -1;
  if (e.key==='ArrowRight') turnAxis.x =  1;
  if (e.key===' ') { jumpPressed = true; fireHeld = true; }

  if (e.key === '1') currentWeapon = 0;
  if (e.key === '2') currentWeapon = 1;

  if (e.key.toLowerCase() === 't') snapTurnEnabled = !snapTurnEnabled; // Toggle
});
window.addEventListener('keyup', (e)=>{
  if (e.key==='w' || e.key==='s') moveAxis.y = 0;
  if (e.key==='a' || e.key==='d') moveAxis.x = 0;
  if (e.key==='ArrowLeft' || e.key==='ArrowRight') turnAxis.x = 0;
  if (e.key===' ') { jumpPressed = false; fireHeld = false; }
});

// XR
let rightStickClickPrev = false; // für Snap-Toggle
function readXRInput(session){
  moveAxis.x = moveAxis.y = 0;
  turnAxis.x = turnAxis.y = 0;
  jumpPressed = false;

  for (const source of session.inputSources){
    if (!source.gamepad) continue;
    const { axes, buttons } = source.gamepad;
    const dead = 0.1;
    const axX = Math.abs(axes[2]||0) > dead ? axes[2] : 0;
    const axY = Math.abs(axes[3]||0) > dead ? axes[3] : 0;

    if (source.handedness === 'left'){
      moveAxis.x = axX; moveAxis.y = axY;
      const triggerPressed = (buttons[0] && buttons[0].pressed) || false;
      if (triggerPressed) fireHeld = true;

    } else if (source.handedness === 'right'){
      turnAxis.x = axX; turnAxis.y = axY;

      // A (heuristisch index 4) = Jump
      jumpPressed = buttons.some((b,i)=> i===4 ? b.pressed : false);

      // B (index 5) = Weapon cycle (Edge)
      const bPressed = (buttons[5] && buttons[5].pressed) || false;
      if (bPressed && !rightBWasPressed) currentWeapon = (currentWeapon + 1) % weapons.length;
      rightBWasPressed = bPressed;

      // Right stick click (häufig index 3) = Snap-Turn Toggle (Edge)
      const stickClick = (buttons[3] && buttons[3].pressed) || false;
      if (stickClick && !rightStickClickPrev) snapTurnEnabled = !snapTurnEnabled;
      rightStickClickPrev = stickClick;
    }
  }
}
function onXRFrame(){
  if (renderer.xr.isPresenting){
    readXRInput(renderer.xr.getSession());
  }
}
controllerLeft.addEventListener('selectstart', ()=> { fireHeld = true; });
controllerLeft.addEventListener('selectend',   ()=> { fireHeld = false; });

// --- Movement / Physics ---
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const moveSpeed = 5;
let playerYRotation = 0;

// Vertical physics
let vy = 0, grounded = false, coyoteTimer = 0;
const COYOTE_MAX = 0.1, JUMP = 8, GRAV = -9.8 * 0.5, PROBE = 0.25;

const downRay = new THREE.Raycaster(), downDir = new THREE.Vector3(0,-1,0);
const upRay   = new THREE.Raycaster(),   upDir = new THREE.Vector3(0, 1,0);

function landIfGroundClose(pos){
  downRay.set(new THREE.Vector3(pos.x, pos.y + 0.2, pos.z), downDir);
  const hits = downRay.intersectObjects(walkableMeshes, true);
  if (!hits.length) return false;
  const hit = hits[0];
  if (vy <= 0 && hit.distance <= (0.2 + PROBE)) {
    pos.y = pos.y + 0.2 - hit.distance;
    vy = 0; grounded = true; coyoteTimer = 0;
    return true;
  }
  return false;
}
function blockCeiling(pos, dt, playerHeight){
  if (vy <= 0) return;
  const headOldY = playerGroup.position.y + playerHeight;
  upRay.set(new THREE.Vector3(pos.x, headOldY, pos.z), upDir);
  upRay.far = (vy * dt) + 0.05;
  const hits = upRay.intersectObjects(staticColliders.map(e=>e.obj), true);
  if (!hits.length) return;
  const hit = hits[0];
  const clampY = hit.point.y - playerHeight;
  if (pos.y > clampY) pos.y = clampY;
  vy = 0;
}

// Weapons / Bullets
const weapons = [
  { name: 'AR', speed: 16, radius: 0.04, color: 0x00ffea, fireRate: 10 },
  { name: 'BR', speed: 28, radius: 0.03, color: 0xff6a00, fireRate: 5  },
];
let currentWeapon = 0, fireCooldown = 0;
const bulletPool = [], bullets = [];
function acquireBullet(radius, color){
  let m = bulletPool.pop();
  if (!m){
    m = new THREE.Mesh(new THREE.SphereGeometry(radius, 8, 8), new THREE.MeshBasicMaterial({ color }));
  } else {
    if (!m.geometry.parameters || m.geometry.parameters.radius !== radius){
      m.geometry.dispose(); m.geometry = new THREE.SphereGeometry(radius, 8, 8);
    }
    m.material.color.setHex(color);
  }
  m.visible = true; return m;
}
function releaseBullet(m){ m.visible=false; m.position.set(0,-999,0); if (m.velocity) m.velocity.set(0,0,0); bulletPool.push(m); }

// --- Update ---
function update(dt){
  // Turning (Snap oder Smooth)
  if (snapTurnEnabled){
    snapDebounce = Math.max(0, snapDebounce - dt);
    if (snapDebounce === 0){
      if (turnAxis.x >  0.6) { playerYRotation -= SNAP_ANGLE; snapDebounce = 0.2; }
      if (turnAxis.x < -0.6) { playerYRotation += SNAP_ANGLE; snapDebounce = 0.2; }
    }
  } else {
    playerYRotation -= turnAxis.x * 0.05;
  }
  playerGroup.rotation.y = playerYRotation;

  // Move (X/Z)
  if (Math.abs(moveAxis.x) > 0 || Math.abs(moveAxis.y) > 0) {
    direction.set(moveAxis.x, 0, moveAxis.y).normalize();
    const yRot = new THREE.Matrix4().makeRotationY(playerYRotation);
    direction.applyMatrix4(yRot);
    velocity.x = direction.x * moveSpeed;
    velocity.z = direction.z * moveSpeed;
  } else { velocity.x = 0; velocity.z = 0; }

  // Vertical
  if (!grounded) coyoteTimer = Math.max(0, coyoteTimer - dt);
  if (jumpPressed && (grounded || coyoteTimer > 0)){ vy = JUMP; grounded = false; coyoteTimer = 0; }
  vy += GRAV * dt;

  const newPos = playerGroup.position.clone();
  newPos.x += velocity.x * dt;
  newPos.z += velocity.z * dt;
  newPos.y += vy * dt;

  const playerHeight = 1.6, playerRadius = 0.5;
  let finalPos = newPos.clone();

  // Seiten-Kollisionen (statische Boxen)
  const wallEntries = staticColliders.filter(e => e.obj !== ground && e.obj !== interiorFloor && e.obj !== roof);
  for (const { box } of wallEntries){
    const pBox = {
      minX: finalPos.x - playerRadius, maxX: finalPos.x + playerRadius,
      minZ: finalPos.z - playerRadius, maxZ: finalPos.z + playerRadius,
      minY: finalPos.y,                 maxY: finalPos.y + playerHeight
    };
    if (pBox.maxX > box.min.x && pBox.minX < box.max.x &&
        pBox.maxZ > box.min.z && pBox.minZ < box.max.z){
      if (finalPos.y < box.max.y && finalPos.y + playerHeight > box.min.y){
        const oldBox = {
          minX: playerGroup.position.x - playerRadius, maxX: playerGroup.position.x + playerRadius,
          minZ: playerGroup.position.z - playerRadius, maxZ: playerGroup.position.z + playerRadius
        };
        if (!(oldBox.maxX > box.min.x && oldBox.minX < box.max.x)) finalPos.x = playerGroup.position.x;
        if (!(oldBox.maxZ > box.min.z && oldBox.minZ < box.max.z)) finalPos.z = playerGroup.position.z;
      }
    }
  }

  // Decke blocken, dann Bodenfang
  blockCeiling(finalPos, dt, playerHeight);
  const landed = landIfGroundClose(finalPos);
  if (!landed && grounded && vy < 0){ grounded = false; coyoteTimer = COYOTE_MAX; }

  playerGroup.position.copy(finalPos);

  // Shooting (Cooldown + Pool + Waffen-Config)
  fireCooldown = Math.max(0, fireCooldown - dt);
  if (fireHeld && fireCooldown === 0){
    const w = weapons[currentWeapon];
    fireCooldown = 1 / w.fireRate;

    const bullet = acquireBullet(w.radius, w.color);
    const origin = controllerLeft.getWorldPosition(new THREE.Vector3());
    const quat   = controllerLeft.getWorldQuaternion(new THREE.Quaternion());
    bullet.position.copy(origin);
    bullet.quaternion.copy(quat);

    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(quat).normalize();
    bullet.velocity = dir.multiplyScalar(w.speed);
    scene.add(bullet);
    bullets.push(bullet);
  }

  // Bullets
  const staticObjs = staticColliders.map(e => e.obj);
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    const old = b.position.clone();
    b.position.addScaledVector(b.velocity, dt);

    const ray = new THREE.Raycaster(old, b.velocity.clone().normalize());
    const dist = b.velocity.length() * dt;
    ray.far = dist;
    const hits = ray.intersectObjects(staticObjs);
    const hit = hits.length > 0;

    if (hit || b.position.length() > 150){
      scene.remove(b);
      releaseBullet(b);
      bullets.splice(i,1);
    }
  }
}

// --- Loop ---
renderer.setAnimationLoop(()=>{
  const dt = Math.min(clock.getDelta(), 1/30);
  onXRFrame();
  update(dt);
  renderer.render(scene, camera);
});

// --- Resize ---
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// --- XR per-frame ---
function onXRFrame(){
  if (renderer.xr.isPresenting){
    readXRInput(renderer.xr.getSession());
  }
}
</script>
</body>
</html>
