<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo-Style WebXR Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

        // Basic setup for WebXR with Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Player setup (rig for locomotion)
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        // Camera is added to playerGroup; XR will update its local matrix
        playerGroup.add(camera);
        // No manual camera.position set; XR handles head height

        // Simplified Spartan body (positioned below camera - adjust based on head height)
        const playerBody = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0x006400 }) // Green Spartan armor color
        );
        playerBody.position.y = -1.6; // Approximate below head
        playerGroup.add(playerBody);

        // Controllers added to playerGroup so they move with locomotion
        const controller1 = renderer.xr.getController(0); // Left controller
        const controller2 = renderer.xr.getController(1); // Right controller
        playerGroup.add(controller1);
        playerGroup.add(controller2);

        // Gun in left hand (simplified as a box for Master Chief's assault rifle)
        const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0, -0.1, -0.3); // Position in hand
        gun.rotation.x = -Math.PI / 2;
        controller1.add(gun);

        // Shooting mechanics
        let bullets = [];
        controller1.addEventListener('selectstart', () => {
            // Fire bullet on left trigger
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            bullet.position.copy(controller1.getWorldPosition(new THREE.Vector3()));
            bullet.quaternion.copy(controller1.getWorldQuaternion(new THREE.Quaternion()));
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(bullet.quaternion);
            bullet.velocity = direction.multiplyScalar(10); // Speed
            scene.add(bullet);
            bullets.push(bullet);
        });

        // Map: 20x20 ground plane with some unevenness and obstacles
        const groundGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
        groundGeometry.rotateX(-Math.PI / 2);
        // Add some height variation
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 2; i < vertices.length; i += 3) {
            vertices[i] += Math.random() * 0.5 - 0.25; // Small hills/valleys
        }
        groundGeometry.attributes.position.needsUpdate = true;
        groundGeometry.computeVertexNormals();
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        scene.add(ground);

        // Obstacles (simple boxes)
        for (let i = 0; i < 10; i++) {
            const obstacle = new THREE.Mesh(
                new THREE.BoxGeometry(Math.random() * 2 + 1, Math.random() * 2 + 1, Math.random() * 2 + 1),
                new THREE.MeshStandardMaterial({ color: 0xA9A9A9 })
            );
            obstacle.position.set(
                Math.random() * 20 - 10,
                obstacle.scale.y / 2,
                Math.random() * 20 - 10
            );
            scene.add(obstacle);
        }

        // Central fortress (simple structure)
        const fortressGroup = new THREE.Group();
        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); // Dark color
        const wall1 = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 0.5), wallMaterial);
        wall1.position.set(0, 1.5, 2.5);
        fortressGroup.add(wall1);
        const wall2 = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 0.5), wallMaterial);
        wall2.position.set(0, 1.5, -2.5);
        fortressGroup.add(wall2);
        const wall3 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 5), wallMaterial);
        wall3.position.set(2.5, 1.5, 0);
        fortressGroup.add(wall3);
        const wall4 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 5), wallMaterial);
        wall4.position.set(-2.5, 1.5, 0);
        fortressGroup.add(wall4);
        // Entrance (gap in front wall)
        // Roof
        const roof = new THREE.Mesh(new THREE.BoxGeometry(5, 0.5, 5), wallMaterial);
        roof.position.set(0, 3.25, 0);
        fortressGroup.add(roof);
        // Interior floor
        const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 4), groundMaterial);
        interiorFloor.position.set(0, 0.05, 0);
        fortressGroup.add(interiorFloor);
        scene.add(fortressGroup);

        // Sky with Halo ring (simple skybox and ring model)
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Halo ring (torus for simplicity)
        const ringGeometry = new THREE.TorusGeometry(100, 5, 16, 100);
        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const haloRing = new THREE.Mesh(ringGeometry, ringMaterial);
        haloRing.rotation.x = Math.PI / 2;
        haloRing.position.set(0, 200, -300); // Visible in the sky
        scene.add(haloRing);

        // Movement controls
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 5;
        const jumpSpeed = 8; // Higher jump due to lower gravity
        const gravity = -9.8 * 0.5; // Half Earth gravity
        let isJumping = false;

        // Controller grips for hands (optional visualization) - add to playerGroup
        const grip1 = renderer.xr.getControllerGrip(0);
        const grip2 = renderer.xr.getControllerGrip(1);
        playerGroup.add(grip1);
        playerGroup.add(grip2);

        // Input handling
        const leftThumbstick = { x: 0, y: 0 };
        const rightThumbstick = { x: 0, y: 0 };
        let jumpPressed = false;

        // Mock input for desktop testing (use gamepad API in VR)
        window.addEventListener('keydown', (e) => {
            // For testing without VR: WASD movement, space jump, arrow keys turn
            if (e.key === 'w') leftThumbstick.y = 1;
            if (e.key === 's') leftThumbstick.y = -1;
            if (e.key === 'a') leftThumbstick.x = -1;
            if (e.key === 'd') leftThumbstick.x = 1;
            if (e.key === 'ArrowLeft') rightThumbstick.x = -1;
            if (e.key === 'ArrowRight') rightThumbstick.x = 1;
            if (e.key === ' ') jumpPressed = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 's') leftThumbstick.y = 0;
            if (e.key === 'a' || e.key === 'd') leftThumbstick.x = 0;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') rightThumbstick.x = 0;
            if (e.key === ' ') jumpPressed = false;
        });

        // In VR, use gamepad axes - for Quest, thumbstick is axes[2] and [3]
        function onXRFrame() {
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                const inputSources = session.inputSources;
                inputSources.forEach((source, index) => {
                    if (source.gamepad) {
                        const axes = source.gamepad.axes;
                        if (index === 0) { // Left controller
                            leftThumbstick.x = axes[2] || 0; // Thumbstick horizontal
                            leftThumbstick.y = axes[3] || 0; // Thumbstick vertical
                        } else if (index === 1) { // Right controller
                            rightThumbstick.x = axes[2] || 0; // Thumbstick horizontal for turn
                            // A button for jump (button[2] for A on right Quest controller)
                            jumpPressed = source.gamepad.buttons[2]?.pressed || false;
                        }
                    }
                });
            }
        }

        // Animation loop
        function animate(time) {
            renderer.setAnimationLoop(animate);

            onXRFrame();

            // Movement (horizontal in camera XZ plane)
            direction.z = -leftThumbstick.y; // Forward/back
            direction.x = leftThumbstick.x; // Strafe
            direction.normalize();
            direction.applyQuaternion(camera.quaternion);
            velocity.x = direction.x * moveSpeed;
            velocity.z = direction.z * moveSpeed;

            // Turning (smooth turn with right thumbstick)
            playerGroup.rotation.y -= rightThumbstick.x * 0.05; // Rotate speed

            // Jumping and gravity
            if (playerGroup.position.y > 0) {
                velocity.y += gravity * 0.016; // Delta time approx
            } else {
                velocity.y = 0;
                playerGroup.position.y = 0;
                isJumping = false;
            }
            if (jumpPressed && !isJumping) {
                velocity.y = jumpSpeed;
                isJumping = true;
            }

            playerGroup.position.add(velocity.clone().multiplyScalar(0.016));

            // Bullet update (use world position for spawning)
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.velocity.clone().multiplyScalar(0.016));
                if (bullet.position.length() > 100) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
