<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo-Style WebXR Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/webxr/VRButton.js';

        // Basic setup for WebXR with Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Clock for delta time
        const clock = new THREE.Clock();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Player setup (rig for locomotion)
        const playerGroup = new THREE.Group();
        playerGroup.position.set(0, 3.25 + 1.6, 0); // Spawn on top of fortress roof
        scene.add(playerGroup);
        // Camera is added to playerGroup; XR will update its local matrix
        playerGroup.add(camera);
        // No manual camera.position set; XR handles head height

        // Simplified Spartan body (positioned below camera - adjust based on head height)
        const playerBody = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0x006400 }) // Green Spartan armor color
        );
        playerBody.position.y = -1.6; // Approximate below head
        playerGroup.add(playerBody);

        // Controllers added to playerGroup so they move with locomotion
        const controller1 = renderer.xr.getController(0); // Left controller
        const controller2 = renderer.xr.getController(1); // Right controller
        playerGroup.add(controller1);
        playerGroup.add(controller2);

        // Gun in left hand (simplified as a box for Master Chief's assault rifle)
        const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0, -0.1, -0.3); // Position in hand
        // Rotated so the long side (barrel) points forward
        gun.rotation.x = 0;
        gun.rotation.y = 0;
        gun.rotation.z = 0;
        controller1.add(gun);

        // Store all collidable objects
        const collidableObjects = [];

        // Shooting mechanics
        let bullets = [];
        controller1.addEventListener('selectstart', () => {
            // Fire bullet on left trigger
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            bullet.position.copy(controller1.getWorldPosition(new THREE.Vector3()));
            bullet.quaternion.copy(controller1.getWorldQuaternion(new THREE.Quaternion()));
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(bullet.quaternion);
            bullet.velocity = direction.multiplyScalar(10); // Speed
            scene.add(bullet);
            bullets.push(bullet);
        });

        // Map: 20x20 ground plane with some unevenness and obstacles
        const groundGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
        groundGeometry.rotateX(-Math.PI / 2);
        // Add some height variation
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 2; i < vertices.length; i += 3) {
            vertices[i] += Math.random() * 0.5 - 0.25; // Small hills/valleys
        }
        groundGeometry.attributes.position.needsUpdate = true;
        groundGeometry.computeVertexNormals();
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        scene.add(ground);

        // Obstacles (simple boxes)
        for (let i = 0; i < 10; i++) {
            const obstacle = new THREE.Mesh(
                new THREE.BoxGeometry(Math.random() * 2 + 1, Math.random() * 2 + 1, Math.random() * 2 + 1),
                new THREE.MeshStandardMaterial({ color: 0xA9A9A9 })
            );
            obstacle.position.set(
                Math.random() * 20 - 10,
                obstacle.geometry.parameters.height / 2,
                Math.random() * 20 - 10
            );
            scene.add(obstacle);
            collidableObjects.push(obstacle);
        }

        // Central fortress (simple structure)
        const fortressGroup = new THREE.Group();
        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); // Dark color
        
        // Front wall with entrance gap
        const wall1Left = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 0.5), wallMaterial);
        wall1Left.position.set(-1.75, 1.5, 2.5);
        fortressGroup.add(wall1Left);
        collidableObjects.push(wall1Left);
        const wall1Right = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 0.5), wallMaterial);
        wall1Right.position.set(1.75, 1.5, 2.5);
        fortressGroup.add(wall1Right);
        collidableObjects.push(wall1Right);
        // Entrance lintel (top of doorway)
        const lintel = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 0.5), wallMaterial);
        lintel.position.set(0, 2.75, 2.5);
        fortressGroup.add(lintel);
        collidableObjects.push(lintel);
        
        // Back wall
        const wall2 = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 0.5), wallMaterial);
        wall2.position.set(0, 1.5, -2.5);
        fortressGroup.add(wall2);
        collidableObjects.push(wall2);
        
        // Left wall
        const wall3 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 5), wallMaterial);
        wall3.position.set(2.5, 1.5, 0);
        fortressGroup.add(wall3);
        collidableObjects.push(wall3);
        
        // Right wall
        const wall4 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 5), wallMaterial);
        wall4.position.set(-2.5, 1.5, 0);
        fortressGroup.add(wall4);
        collidableObjects.push(wall4);
        
        // Roof
        const roof = new THREE.Mesh(new THREE.BoxGeometry(5, 0.5, 5), wallMaterial);
        roof.position.set(0, 3.25, 0);
        fortressGroup.add(roof);
        collidableObjects.push(roof);
        
        // Interior floor
        const interiorFloor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 4), groundMaterial);
        interiorFloor.position.set(0, 0.05, 0);
        fortressGroup.add(interiorFloor);
        collidableObjects.push(interiorFloor);
        
        scene.add(fortressGroup);
        
        // Add ground to collidable objects
        collidableObjects.push(ground);

        // Sky with Halo ring (simple skybox and ring model)
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Halo ring (torus for simplicity)
        const ringGeometry = new THREE.TorusGeometry(100, 5, 16, 100);
        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const haloRing = new THREE.Mesh(ringGeometry, ringMaterial);
        haloRing.rotation.x = Math.PI / 2;
        haloRing.position.set(0, 200, -300); // Visible in the sky
        scene.add(haloRing);

        // Movement controls
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 5;
        const jumpSpeed = 8; // Higher jump due to lower gravity
        const gravity = -9.8 * 0.5; // Half Earth gravity
        let isJumping = false;
        let playerYRotation = 0; // Track player's Y rotation separately
        
        // Raycaster for collision detection
        const raycaster = new THREE.Raycaster();

        // Controller grips for hands (optional visualization) - add to playerGroup
        const grip1 = renderer.xr.getControllerGrip(0);
        const grip2 = renderer.xr.getControllerGrip(1);
        playerGroup.add(grip1);
        playerGroup.add(grip2);

        // Input handling
        let leftThumbstick = { x: 0, y: 0 };
        let rightThumbstick = { x: 0, y: 0 };
        let jumpPressed = false;

        // Mock input for desktop testing (use gamepad API in VR)
        window.addEventListener('keydown', (e) => {
            // For testing without VR: WASD movement, space jump, arrow keys turn
            if (e.key === 'w') leftThumbstick.y = -1; // Adjusted for forward
            if (e.key === 's') leftThumbstick.y = 1;
            if (e.key === 'a') leftThumbstick.x = -1;
            if (e.key === 'd') leftThumbstick.x = 1;
            if (e.key === 'ArrowLeft') rightThumbstick.x = -1;
            if (e.key === 'ArrowRight') rightThumbstick.x = 1;
            if (e.key === ' ') jumpPressed = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 's') leftThumbstick.y = 0;
            if (e.key === 'a' || e.key === 'd') leftThumbstick.x = 0;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') rightThumbstick.x = 0;
            if (e.key === ' ') jumpPressed = false;
        });

        // In VR, use gamepad axes - for Quest, thumbstick is axes[2] and [3]
        function onXRFrame() {
            // Reset inputs first to prevent drift
            leftThumbstick = { x: 0, y: 0 };
            rightThumbstick = { x: 0, y: 0 };
            jumpPressed = false;
            
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                const inputSources = session.inputSources;
                inputSources.forEach((source, index) => {
                    if (source.gamepad) {
                        const axes = source.gamepad.axes;
                        // Apply deadzone to prevent drift
                        const deadzone = 0.1;
                        if (index === 0) { // Left controller
                            const x = axes[2] || 0;
                            const y = axes[3] || 0;
                            leftThumbstick.x = Math.abs(x) > deadzone ? x : 0;
                            leftThumbstick.y = Math.abs(y) > deadzone ? y : 0;
                        } else if (index === 1) { // Right controller
                            const x = axes[2] || 0;
                            rightThumbstick.x = Math.abs(x) > deadzone ? x : 0;
                            // A button for jump (button[4] for A on right Quest controller)
                            jumpPressed = source.gamepad.buttons[4]?.pressed || false;
                        }
                    }
                });
            }
        }

        // Update function with delta time
        function update(dt) {
            // Turning (smooth turn with right thumbstick) - update player rotation
            playerYRotation -= rightThumbstick.x * 0.05;
            playerGroup.rotation.y = playerYRotation;

            // Movement (forward/backward and strafe based on player's Y rotation only)
            if (Math.abs(leftThumbstick.x) > 0 || Math.abs(leftThumbstick.y) > 0) {
                direction.set(0, 0, 0);
                direction.x = leftThumbstick.x; // Strafe left/right
                direction.z = leftThumbstick.y; // Forward/back (positive y = backward)
                direction.normalize();
                
                // Apply only Y rotation to movement direction (not full camera quaternion)
                const yRotationMatrix = new THREE.Matrix4().makeRotationY(playerYRotation);
                direction.applyMatrix4(yRotationMatrix);
                
                velocity.x = direction.x * moveSpeed;
                velocity.z = direction.z * moveSpeed;
            } else {
                velocity.x = 0;
                velocity.z = 0;
            }

            // Gravity
            velocity.y += gravity * dt;
            
            // Calculate new position
            const deltaPosition = velocity.clone().multiplyScalar(dt);
            const newPosition = playerGroup.position.clone().add(deltaPosition);
            
            // Collision detection
            const playerHeight = 1.6;
            const playerRadius = 0.5;
            let finalPosition = newPosition.clone();
            let onGround = false;
            let groundHeight = 0;
            
            // Check collision with all objects
            for (const obj of collidableObjects) {
                const box = new THREE.Box3().setFromObject(obj);
                
                // Check if player overlaps with object horizontally
                const playerBox = {
                    minX: finalPosition.x - playerRadius,
                    maxX: finalPosition.x + playerRadius,
                    minZ: finalPosition.z - playerRadius,
                    maxZ: finalPosition.z + playerRadius,
                    minY: finalPosition.y,
                    maxY: finalPosition.y + playerHeight
                };
                
                // Horizontal collision check
                if (playerBox.maxX > box.min.x && playerBox.minX < box.max.x &&
                    playerBox.maxZ > box.min.z && playerBox.minZ < box.max.z) {
                    
                    // Vertical collision - standing on top
                    if (velocity.y <= 0 && 
                        playerGroup.position.y >= box.max.y &&
                        finalPosition.y <= box.max.y + 0.1) {
                        groundHeight = Math.max(groundHeight, box.max.y);
                        onGround = true;
                    }
                    // Vertical collision - hitting from below
                    else if (velocity.y > 0 && 
                             playerGroup.position.y + playerHeight <= box.min.y &&
                             finalPosition.y + playerHeight >= box.min.y) {
                        finalPosition.y = box.min.y - playerHeight;
                        velocity.y = 0;
                    }
                    // Horizontal collision - block movement
                    else if (finalPosition.y < box.max.y && 
                             finalPosition.y + playerHeight > box.min.y) {
                        
                        // Determine which axis to block based on previous position
                        const oldBox = {
                            minX: playerGroup.position.x - playerRadius,
                            maxX: playerGroup.position.x + playerRadius,
                            minZ: playerGroup.position.z - playerRadius,
                            maxZ: playerGroup.position.z + playerRadius
                        };
                        
                        // If we weren't overlapping horizontally before, block X movement
                        if (!(oldBox.maxX > box.min.x && oldBox.minX < box.max.x)) {
                            finalPosition.x = playerGroup.position.x;
                        }
                        // If we weren't overlapping in Z before, block Z movement
                        if (!(oldBox.maxZ > box.min.z && oldBox.minZ < box.max.z)) {
                            finalPosition.z = playerGroup.position.z;
                        }
                    }
                }
            }
            
            // Ground collision (y = 0)
            if (finalPosition.y <= 0 && velocity.y <= 0) {
                groundHeight = Math.max(groundHeight, 0);
                onGround = true;
            }
            
            // Apply final position
            if (onGround) {
                finalPosition.y = groundHeight;
                velocity.y = 0;
                isJumping = false;
            }
            
            playerGroup.position.copy(finalPosition);
            
            // Jumping
            if (jumpPressed && !isJumping) {
                velocity.y = jumpSpeed;
                isJumping = true;
            }

            // Bullet update with collision detection
            bullets.forEach((bullet, index) => {
                const oldPosition = bullet.position.clone();
                bullet.position.add(bullet.velocity.clone().multiplyScalar(dt));
                
                // Check collision with objects
                const raycaster = new THREE.Raycaster(oldPosition, bullet.velocity.clone().normalize());
                const intersects = raycaster.intersectObjects(collidableObjects);
                
                let hitSomething = false;
                for (const intersect of intersects) {
                    if (intersect.distance <= bullet.velocity.length() * dt) {
                        hitSomething = true;
                        break;
                    }
                }
                
                if (hitSomething || bullet.position.length() > 100) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });
        }

        // Animation loop with proper delta time
        renderer.setAnimationLoop((time) => {
            const dt = Math.min(clock.getDelta(), 1/30); // clamp für Ausreißer
            onXRFrame();      // Eingaben lesen
            update(dt);       // Physik/Bewegung/Schüsse
            renderer.render(scene, camera);
        });

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
